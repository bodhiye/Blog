<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>叶琼州的代码小窝 on 叶琼州的代码小窝</title>
    <link>https://yeqiongzhou.top/</link>
    <description>Recent content in 叶琼州的代码小窝 on 叶琼州的代码小窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 06 Mar 2019 19:23:25 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>机器人的运动范围</title>
      <link>https://yeqiongzhou.top/2019/03/offer66/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:25 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer66/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int getSum(int n) {
    int sum = 0;
    while (n) {
        sum += n % 10;
        n /= 10;
    }
    return sum;
}

int moving(int threshold, int i, int j, int rows, int cols, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;flag) {
    if (i &amp;lt; 0 || i &amp;gt;= rows || j &amp;lt; 0 || j &amp;gt;= cols || flag[i][j] == 1 || getSum(i) + getSum(j) &amp;gt; threshold)
        return 0;
    flag[i][j] = 1;
    return moving(threshold, i - 1, j, rows, cols, flag) + moving(threshold, i + 1, j, rows, cols, flag) +
           moving(threshold, i, j - 1, rows, cols, flag) + moving(threshold, i, j + 1, rows, cols, flag) + 1;
}

int movingCount(int threshold, int rows, int cols) {
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; flag(rows);
    for (int i = 0; i &amp;lt; rows; i++)
        flag[i].resize(cols, 0);
    return moving(threshold, 0, 0, rows, cols, flag);
}

int main() {
    ios::sync_with_stdio(false);
    int m, n, k;
    cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    cout &amp;lt;&amp;lt; movingCount(k, m, n);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>矩阵中的路径</title>
      <link>https://yeqiongzhou.top/2019/03/offer65/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:21 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer65/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串&amp;rdquo;bcced&amp;rdquo;的路径，但是矩阵中不包含&amp;rdquo;abcb&amp;rdquo;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

bool path(char *matrix, int rows, int cols, int i, int j, char *str, int k, vector&amp;lt;bool&amp;gt; flag) {
    int index = i * cols + j;
    if (i &amp;lt; 0 || i &amp;gt;= rows || j &amp;lt; 0 || j &amp;gt;= cols || matrix[index] != str[k] || flag[index])
        return false;
    if (k == strlen(str) - 1)
        return true;
    flag[index] = true;
    if (path(matrix, rows, cols, i - 1, j, str, k + 1, flag) || path(matrix, rows, cols, i + 1, j, str, k + 1, flag) ||
        path(matrix, rows, cols, i, j - 1, str, k + 1, flag) || path(matrix, rows, cols, i, j + 1, str, k + 1, flag))
        return true;
    flag[index] = false;
    return false;
}

bool hasPath(char *matrix, int rows, int cols, char *str) {
    vector&amp;lt;bool&amp;gt; flag(rows * cols, false);
    for (int i = 0; i &amp;lt; rows; i++)
        for (int j = 0; j &amp;lt; cols; j++)
            if (path(matrix, rows, cols, i, j, str, 0, flag))
                return true;
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    int rows, cols;
    char s[101], str[101];
    cin &amp;gt;&amp;gt; rows &amp;gt;&amp;gt; cols &amp;gt;&amp;gt; s &amp;gt;&amp;gt; str;
    cout &amp;lt;&amp;lt; hasPath(s, rows, cols, str);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>滑动窗口的最大值</title>
      <link>https://yeqiongzhou.top/2019/03/offer64/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:18 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer64/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;deque&amp;gt;

using namespace std;

vector&amp;lt;int&amp;gt; maxInWindows(const vector&amp;lt;int&amp;gt; &amp;amp;num, unsigned int size) {
    vector&amp;lt;int&amp;gt; v;
    deque&amp;lt;int&amp;gt; d;
    for (unsigned int i = 0; i &amp;lt; num.size(); ++i) {
        while (d.size() &amp;amp;&amp;amp; num[d.back()] &amp;lt;= num[i])
            d.pop_back();
        if (d.size() &amp;amp;&amp;amp; i - d.front() + 1 &amp;gt; size)
            d.pop_front();
        d.push_back(i);
        if (size &amp;amp;&amp;amp; i + 1 &amp;gt;= size)
            v.push_back(num[d.front()]);
    }
    return v;
}

int main() {
    ios::sync_with_stdio(false);
    vector&amp;lt;int&amp;gt; v, res;
    int n, k, tmp;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; tmp;
        v.push_back(tmp);
    }
    res = maxInWindows(v, k);
    for (auto it = res.begin(); it != res.end(); ++it)
        cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>数据流中的中位数</title>
      <link>https://yeqiongzhou.top/2019/03/offer63/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:13 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer63/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

vector&amp;lt;int&amp;gt; v;
int n;

void Insert(int num) {
    v.push_back(num);
    n = v.size();
    for (int i = n - 1; i &amp;gt; 0 &amp;amp;&amp;amp; v[i] &amp;lt; v[i - 1]; --i)
        swap(v[i], v[i - 1]);
}

double GetMedian() {
    return (v[(n - 1) &amp;gt;&amp;gt; 1] + v[n &amp;gt;&amp;gt; 1]) / 2.0;
}

int main() {
    ios::sync_with_stdio(false);
    int m, tmp;
    cin &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; m; i++) {
        cin &amp;gt;&amp;gt; tmp;
        Insert(tmp);
    }
    cout &amp;lt;&amp;lt; GetMedian();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>二叉搜索树的第k个结点</title>
      <link>https://yeqiongzhou.top/2019/03/offer62/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:07 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer62/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

int count = 0;

TreeNode *KthNode(TreeNode *pRoot, int k) {
    if (pRoot) {
        TreeNode *node = KthNode(pRoot-&amp;gt;left, k);
        if (node) return node;
        if (++count == k)return pRoot;
        node = KthNode(pRoot-&amp;gt;right, k);
        if (node)return node;
    }
    return NULL;
}

int main() {
    ios::sync_with_stdio(false);
    int k;
    cin &amp;gt;&amp;gt; k;
    TreeNode *root = NULL;
    root = newTree();
    cout &amp;lt;&amp;lt; KthNode(root, k)-&amp;gt;val;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>序列化二叉树</title>
      <link>https://yeqiongzhou.top/2019/03/offer61/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:03 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer61/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请实现两个函数，分别用来序列化和反序列化二叉树&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

void preOrder(TreeNode *pRoot)
{
    if (pRoot)
    {
        cout &amp;lt;&amp;lt; pRoot-&amp;gt;val &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        preOrder(pRoot-&amp;gt;left);
        preOrder(pRoot-&amp;gt;right);
    }
}

char* Serialize(TreeNode *root) {
    if(!root)return &amp;quot;#&amp;quot;;
    string s=to_string(root-&amp;gt;val);
    s.push_back(&#39;,&#39;);
    char *left = Serialize(root-&amp;gt;left);
    char *right = Serialize(root-&amp;gt;right);
    char *res = new char[strlen(left) + strlen(right) + s.size()];
    strcpy(res, s.c_str());
    strcat(res, left);
    strcat(res, right);
    return res;
}

TreeNode* decode(char *&amp;amp;str) {
    if(*str==&#39;#&#39;){
        str++;
        return NULL;
    }
    int num = 0;
    while(*str != &#39;,&#39;)
        num = num*10 + (*(str++)-&#39;0&#39;);
    str++;
    TreeNode *root = new TreeNode(num);
    root-&amp;gt;left = decode(str);
    root-&amp;gt;right = decode(str);
    return root;
}

TreeNode* Deserialize(char *str) {
    return decode(str);
}

int main() {
    ios::sync_with_stdio(false);
    TreeNode *root = NULL;
    root = newTree();
    cout&amp;lt;&amp;lt;Serialize(root)&amp;lt;&amp;lt;endl;
    TreeNode * res = Deserialize(Serialize(root));
    preOrder(res);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>把二叉树打印成多行</title>
      <link>https://yeqiongzhou.top/2019/03/offer60/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer60/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; Print(TreeNode *pRoot) {
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    if (!pRoot)return res;
    queue&amp;lt;TreeNode *&amp;gt; q;
    q.push(pRoot);
    while (!q.empty()) {
        vector&amp;lt;int&amp;gt; v;
        int size=q.size();
        for (int i = 0; i &amp;lt; size; ++i) {
            TreeNode *tmp = q.front();
            q.pop();
            v.push_back(tmp-&amp;gt;val);
            if (tmp-&amp;gt;left)q.push(tmp-&amp;gt;left);
            if (tmp-&amp;gt;right)q.push(tmp-&amp;gt;right);
        }
        res.push_back(v);
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    TreeNode *root = NULL;
    root = newTree();
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    res = Print(root);
    for (auto it = res.begin(); it != res.end(); ++it) {
        for (auto i = (*it).begin(); i != (*it).end(); ++i)
            cout &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        cout &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>按之字形顺序打印二叉树</title>
      <link>https://yeqiongzhou.top/2019/03/offer59/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:54 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer59/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; Print(TreeNode *pRoot) {
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    if (!pRoot)return res;
    queue&amp;lt;TreeNode *&amp;gt; q;
    q.push(pRoot);
    bool even = false;
    while (!q.empty()) {
        vector&amp;lt;int&amp;gt; v;
        int size=q.size();
        for (int i = 0; i &amp;lt; size; ++i) {
            TreeNode *tmp = q.front();
            q.pop();
            v.push_back(tmp-&amp;gt;val);
            if (tmp-&amp;gt;left)q.push(tmp-&amp;gt;left);
            if (tmp-&amp;gt;right)q.push(tmp-&amp;gt;right);
        }
        if (even)
            reverse(v.begin(), v.end());
        even = !even;
        res.push_back(v);
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    TreeNode *root = NULL;
    root = newTree();
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    res = Print(root);
    for (auto it = res.begin(); it != res.end(); ++it) {
        for (auto i = (*it).begin(); i != (*it).end(); ++i)
            cout &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        cout &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>对称的二叉树</title>
      <link>https://yeqiongzhou.top/2019/03/offer58/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:51 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer58/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

bool symmetrical(TreeNode *left, TreeNode *right) {
    if (!left &amp;amp;&amp;amp; !right)
        return true;
    if (left &amp;amp;&amp;amp; right)
        return left-&amp;gt;val == right-&amp;gt;val &amp;amp;&amp;amp; symmetrical(left-&amp;gt;left, right-&amp;gt;right) &amp;amp;&amp;amp;
               symmetrical(left-&amp;gt;right, right-&amp;gt;left);
    return false;
}

bool isSymmetrical(TreeNode *pRoot) {
    if (!pRoot)
        return true;
    return symmetrical(pRoot-&amp;gt;left, pRoot-&amp;gt;right);
}

int main() {
    ios::sync_with_stdio(false);
    TreeNode *root = NULL;
    root = newTree();
    cout &amp;lt;&amp;lt; isSymmetrical(root);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>二叉树的下一个结点</title>
      <link>https://yeqiongzhou.top/2019/03/offer57/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:48 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer57/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next;

    TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}

    TreeLinkNode() {}
};

TreeLinkNode *newTree() {
    TreeLinkNode *node = new TreeLinkNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left-&amp;gt;next = node;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right-&amp;gt;next = node;
        node-&amp;gt;right = newTree();
    }
    return node;
}

TreeLinkNode *GetNext(TreeLinkNode *pNode) {
    if (!pNode)return NULL;
    if (pNode-&amp;gt;right) {
        pNode = pNode-&amp;gt;right;
        while (pNode-&amp;gt;left)pNode = pNode-&amp;gt;left;
        return pNode;
    }
    while (pNode-&amp;gt;next) {
        if (pNode-&amp;gt;next-&amp;gt;left == pNode)
            return pNode-&amp;gt;next;
        pNode = pNode-&amp;gt;next;
    }
    return NULL;
}

int main() {
    ios::sync_with_stdio(false);
    TreeLinkNode *node = newTree();
    TreeLinkNode *pNode;
    TreeLinkNode *res = GetNext(pNode);
    cout &amp;lt;&amp;lt; res-&amp;gt;val;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>删除链表中重复的结点</title>
      <link>https://yeqiongzhou.top/2019/03/offer56/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:44 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer56/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 处理后为 1-&amp;gt;2-&amp;gt;5&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;

    ListNode(int x) : val(x), next(NULL) {}

    ListNode() {}
};

ListNode *newList() {
    ListNode *L = new ListNode;
    L-&amp;gt;next = NULL;
    ListNode *q = L;
    int n;
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        ListNode *p = new ListNode;
        cin &amp;gt;&amp;gt; p-&amp;gt;val;
        q-&amp;gt;next = p;
        q = p;
    }
    q-&amp;gt;next = NULL;
    return L-&amp;gt;next;
}

void print(ListNode *pHead) {
    while (pHead) {
        cout &amp;lt;&amp;lt; pHead-&amp;gt;val &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        pHead = pHead-&amp;gt;next;
    }
}

ListNode *deleteDuplication(ListNode *pHead) {
    if (pHead == NULL || pHead-&amp;gt;next == NULL)
        return pHead;
    if (pHead-&amp;gt;val == pHead-&amp;gt;next-&amp;gt;val) {
        ListNode *pNode = pHead-&amp;gt;next;
        while (pNode != NULL &amp;amp;&amp;amp; pNode-&amp;gt;val == pHead-&amp;gt;val) {
            pNode = pNode-&amp;gt;next;
        }
        return deleteDuplication(pNode);
    } else {
        pHead-&amp;gt;next = deleteDuplication(pHead-&amp;gt;next);
        return pHead;
    }
}

int main() {
    ios::sync_with_stdio(false);
    ListNode *L = newList();
    ListNode *res = deleteDuplication(L);
    print(res);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表中环的入口结点</title>
      <link>https://yeqiongzhou.top/2019/03/offer55/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:40 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer55/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;

    ListNode(int x) : val(x), next(NULL) {}

    ListNode() {}
};

ListNode *newList() {
    ListNode *L = new ListNode;
    L-&amp;gt;next = NULL;
    ListNode *q = L;
    int n;
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        ListNode *p = new ListNode;
        cin &amp;gt;&amp;gt; p-&amp;gt;val;
        q-&amp;gt;next = p;
        q = p;
    }
    q-&amp;gt;next = NULL;
    return L-&amp;gt;next;
}

ListNode *EntryNodeOfLoop(ListNode *pHead) {
    if (pHead == NULL || pHead-&amp;gt;next == NULL)
        return NULL;
    ListNode *p1 = pHead, *p2 = pHead;
    while (p2 != NULL &amp;amp;&amp;amp; p2-&amp;gt;next != NULL) {
        p1 = p1-&amp;gt;next;
        p2 = p2-&amp;gt;next-&amp;gt;next;
        if (p1 == p2) {
            p2 = pHead;
            while (p1 != p2) {
                p1 = p1-&amp;gt;next;
                p2 = p2-&amp;gt;next;
            }
            if (p1 == p2)
                return p1;
        }
    }
    return NULL;
}

int main() {
    ios::sync_with_stdio(false);
    ListNode *L = newList();
    cout &amp;lt;&amp;lt; EntryNodeOfLoop(L)-&amp;gt;val;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>字符流中第一个不重复的字符</title>
      <link>https://yeqiongzhou.top/2019/03/offer54/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:36 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer54/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&amp;rdquo;go&amp;rdquo;时，第一个只出现一次的字符是&amp;rdquo;g&amp;rdquo;。当从该字符流中读出前六个字符“google&amp;rdquo;时，第一个只出现一次的字符是&amp;rdquo;l&amp;rdquo;。&lt;/p&gt;

&lt;h4 id=&#34;输出描述&#34;&gt;输出描述:&lt;/h4&gt;

&lt;p&gt;如果当前字符流没有存在出现一次的字符，返回#字符。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

map&amp;lt;char, int&amp;gt; m;
vector&amp;lt;int&amp;gt; v;

void Insert(char ch) {
    v.push_back(ch);
    m[ch]++;
}

char FirstAppearingOnce() {
    for (auto it = v.begin(); it != v.end(); ++it)
        if (m[*it] == 1)
            return *it;
    return &#39;#&#39;;
}

int main() {
    ios::sync_with_stdio(false);
    char c;
    int n;
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; c;
        Insert(c);
    }
    cout &amp;lt;&amp;lt; FirstAppearingOnce();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>表示数值的字符串</title>
      <link>https://yeqiongzhou.top/2019/03/offer53/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:32 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer53/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&amp;rdquo;+100&amp;rdquo;,&amp;ldquo;5e2&amp;rdquo;,&amp;ldquo;-123&amp;rdquo;,&amp;ldquo;3.1416&amp;rdquo;和&amp;rdquo;-1E-16&amp;rdquo;都表示数值。 但是&amp;rdquo;12e&amp;rdquo;,&amp;ldquo;1a3.14&amp;rdquo;,&amp;ldquo;1.2.3&amp;rdquo;,&amp;ldquo;+-5&amp;rdquo;和&amp;rdquo;12e+4.3&amp;rdquo;都不是。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

bool isNumeric(char *string) {
    int n = strlen(string);
    if (n == 0 || (n == 1 &amp;amp;&amp;amp; (string[0] &amp;lt; &#39;0&#39; || string[0] &amp;gt; &#39;9&#39;)))
        return false;
    bool sign = false, dec = false, hasE = false;
    for (int i = 0; i &amp;lt; n; i++) {
        if (string[i] == &#39;+&#39; || string[i] == &#39;-&#39;) {
            if (!sign &amp;amp;&amp;amp; i &amp;gt; 0 &amp;amp;&amp;amp; string[i - 1] != &#39;e&#39; &amp;amp;&amp;amp; string[i - 1] != &#39;E&#39;)
                return false;
            if (sign &amp;amp;&amp;amp; string[i - 1] != &#39;e&#39; &amp;amp;&amp;amp; string[i - 1] != &#39;E&#39;)
                return false;
            sign = true;
        } else if (string[i] == &#39;e&#39; || string[i] == &#39;E&#39;) {
            if (i == 0 || i == n - 1)
                return false;
            if (hasE)
                return false;
            hasE = true;
        } else if (string[i] == &#39;.&#39;) {
            if (hasE || dec || i == 0 || i == n - 1)
                return false;
            dec = true;
        } else if (string[i] &amp;lt; &#39;0&#39; || string[i] &amp;gt; &#39;9&#39;)
            return false;
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    char a[101];
    cin &amp;gt;&amp;gt; a;
    cout &amp;lt;&amp;lt; isNumeric(a);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>正则表达式匹配</title>
      <link>https://yeqiongzhou.top/2019/03/offer52/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:27 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer52/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请实现一个函数用来匹配包括&amp;rsquo;.&amp;lsquo;和&amp;rsquo;&lt;em&gt;&amp;lsquo;的正则表达式。模式中的字符&amp;rsquo;.&amp;lsquo;表示任意一个字符，而&amp;rsquo;&lt;/em&gt;&amp;lsquo;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&amp;rdquo;aaa&amp;rdquo;与模式&amp;rdquo;a.a&amp;rdquo;和&amp;rdquo;ab*ac*a&amp;rdquo;匹配，但是与&amp;rdquo;aa.a&amp;rdquo;和&amp;rdquo;ab*a&amp;rdquo;均不匹配&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

bool match(char *str, char *pattern) {
    if (*str == &#39;\0&#39; &amp;amp;&amp;amp; *pattern == &#39;\0&#39;)
        return true;
    if (*str != &#39;\0&#39; &amp;amp;&amp;amp; *pattern == &#39;\0&#39;)
        return false;
    if (*(pattern + 1) != &#39;*&#39;) {
        if (*str == *pattern || (*str != &#39;\0&#39; &amp;amp;&amp;amp; *pattern == &#39;.&#39;))
            return match(str + 1, pattern + 1);
        else
            return false;
    } else {
        if (*str == *pattern || (*str != &#39;\0&#39; &amp;amp;&amp;amp; *pattern == &#39;.&#39;))
            return match(str, pattern + 2) || match(str + 1, pattern);
        else
            return match(str, pattern + 2);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>