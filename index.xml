<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>叶琼州的代码小窝 on 叶琼州的代码小窝</title>
    <link>https://yeqiongzhou.com/</link>
    <description>Recent content in 叶琼州的代码小窝 on 叶琼州的代码小窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 03 Aug 2020 23:03:22 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux nohup命令</title>
      <link>https://yeqiongzhou.com/2020/08/nohup/</link>
      <pubDate>Mon, 03 Aug 2020 23:03:22 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/08/nohup/</guid>
      <description>

&lt;hr /&gt;

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;我们平时在远程服务器或者跳板机上执行命令时，如果由于长时间未操作导致服务端未响应，触发了防火墙的闲置超时断开的缺省机制，会导致之前执行的命令中断。&lt;/p&gt;

&lt;h3 id=&#34;命令详解&#34;&gt;命令详解&lt;/h3&gt;

&lt;p&gt;nohup 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。&lt;/p&gt;

&lt;p&gt;nohup命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录文件不可写，则输出重定向到 $HOME/nohup.out 文件中。&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;cksum = no hang up&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;nohup Command [ Arg … ] [　&amp;amp; ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Command：要执行的命令。&lt;/li&gt;
&lt;li&gt;Arg：一些参数，可以指定输出文件。&lt;/li&gt;
&lt;li&gt;&amp;amp;：让命令在后台执行，终端退出后命令仍旧执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;p&gt;1、以下命令在后台执行 root 目录下的 yeqiongzhou.sh 脚本：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;nohup /root/yeqiongzhou.sh &amp;amp;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上命令执行后，在终端如果看到以下输出说明运行成功：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;nohup: ignoring input and appending output to &amp;lsquo;nohup.out&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这时我们打开 root 目录 可以看到生存了 nohup.out 文件。
如果要停止运行，你需要使用以下命令查找到 nohup 运行脚本到 PID，然后使用 kill 命令来删除。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ps -aux | grep &amp;ldquo;yeqiongzhou.sh&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;找到 PID 后，就可以使用 kill PID 来删除该后台进程。&lt;/p&gt;

&lt;p&gt;2、以下命令在后台执行 root 目录下的 yeqiongzhou.sh 脚本，并重定向输入到 yeqiongzhou.log 文件：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;nohup /root/test.sh &amp;gt; yeqiongzhou.log 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;2&amp;gt;&amp;amp;1&lt;/strong&gt;：将标准错误 2 重定向到标准输出 &amp;amp;1 ，标准输出 &amp;amp;1 再被重定向输入到 runoob.log 文件中。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0 – stdin (standard input，标准输入)&lt;/li&gt;
&lt;li&gt;1 – stdout (standard output，标准输出)&lt;/li&gt;
&lt;li&gt;2 – stderr (standard error，标准错误输出)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>不同路径</title>
      <link>https://yeqiongzhou.com/2020/07/unique-paths/</link>
      <pubDate>Thu, 30 Jul 2020 00:23:29 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/07/unique-paths/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;一个机器人位于一个 m x n 网格的左上角（起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.yeqiongzhou.top/unique-paths-ii.jpg&#34; alt=&#34;不同路径&#34; /&gt;&lt;/p&gt;

&lt;p&gt;例如，上图是一个 7 x 3 的网格，有多少可能的路径？&lt;/p&gt;

&lt;h3 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;输入: m = 3, n = 2
输出: 3
解释: 从左上角开始，总共有 3 条路径可以到达右下角。

1. 向右 -&amp;gt; 向右 -&amp;gt; 向下
2. 向右 -&amp;gt; 向下 -&amp;gt; 向右
3. 向下 -&amp;gt; 向右 -&amp;gt; 向右

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;输入: m = 7, n = 3
输出: 28
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;提示&#34;&gt;提示&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= m, n &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;题目数据保证答案小于等于 2 * 10 ^ 9&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;题解&#34;&gt;题解&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	len := uniquePaths(2,3)
	fmt.Println(len)
}

func uniquePaths(m, n int) int {
	f := make([]int, m)
	f[0] = 1
	for i := 0; i &amp;lt; n; i++ {
		for j := 0; j &amp;lt; m; j++ {
			if j-1 &amp;gt;= 0 {
				f[j] += f[j-1]
			}
		}
	}
	return f[len(f)-1]
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Linux cksum命令</title>
      <link>https://yeqiongzhou.com/2020/07/cksum/</link>
      <pubDate>Wed, 29 Jul 2020 23:25:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/07/cksum/</guid>
      <description>

&lt;hr /&gt;

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;最近女朋友要我把相机里旅游时拍的照片发给她，然后我就把照片传到百度云发给她了，她下载后就抱怨说百度云把图片压缩了，导致图片放大后看不清，我马上上百度云看了一下，发现文件大小没有压缩，于是我就把百度云下载的图片和我本地内存卡里的照片比对一下，看百度云是否把我的图片压缩了。这里就可以用到 cksum 命令来检查两个文件是否一致。&lt;/p&gt;

&lt;h3 id=&#34;命令详解&#34;&gt;命令详解&lt;/h3&gt;

&lt;p&gt;Linux cksum 命令用于检查文件的 CRC（Cyclic Redundancy Check 循环冗余检验码）是否正确，确保文件从一个系统传输到另一个系统的过程中不被损坏。&lt;/p&gt;

&lt;p&gt;CRC 是一种排错检查方式，该校验法的标准由 CCITT 所指定，至少可检测到 99.998% 的已知错误。&lt;/p&gt;

&lt;p&gt;指定文件交由指令&amp;rdquo;cksum&amp;rdquo;进行校验后，该指令会返回校验结果供用户核对文件是否正确无误。若不指定任何文件名称或是所给予的文件名为&amp;rdquo;-&amp;ldquo;，则指令&amp;rdquo;cksum&amp;rdquo;会从标准输入设备中读取数据。&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;cksum = checksums&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;cksum [&amp;ndash;help][&amp;ndash;version][文件&amp;hellip;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ndash;help：在线帮助。&lt;/li&gt;
&lt;li&gt;&amp;ndash;version：显示版本信息。&lt;/li&gt;
&lt;li&gt;文件…:需要进行检查的文件路径&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;p&gt;使用指令&amp;rdquo;cksum&amp;rdquo;计算文件 yeqiongzhou.jpg 和 yeqiongzhou-baiduyun.jpg 的一致性，输入如下命令：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;cksum yeqiongzhou.jpg yeqiongzhou-baiduyun.jpg&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上命令执行后，将输出校验码等相关的信息，具体输出信息如下所示：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2415123943 3538944 yeqiongzhou.jpg&lt;br /&gt;
2415123943 3538944 yeqiongzhou-baiduyun.jpg&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面的输出信息中，&lt;code&gt;2415123943&lt;/code&gt;表示校验码，&lt;code&gt;3538944&lt;/code&gt;表示字节数。
可见这两张图片是一模一样的，百度云并没有对照片进行压缩。&lt;/p&gt;

&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;

&lt;p&gt;如果文件中有任何字符被修改，都将改变计算后 CRC 校验码的值。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>不同路径II</title>
      <link>https://yeqiongzhou.com/2020/07/unique-paths-ii/</link>
      <pubDate>Sun, 26 Jul 2020 10:21:21 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/07/unique-paths-ii/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;一个机器人位于一个 m x n 网格的左上角（起始点在下图中标记为“Start”）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.yeqiongzhou.top/unique-paths-ii.jpg&#34; alt=&#34;不同路径II&#34; /&gt;&lt;/p&gt;

&lt;p&gt;网格中的障碍物和空位置分别用 1 和 0 来表示。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;m 和 n 的值均不超过 100。&lt;/p&gt;

&lt;h3 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：

1. 向右 -&amp;gt; 向右 -&amp;gt; 向下 -&amp;gt; 向下
2. 向下 -&amp;gt; 向下 -&amp;gt; 向右 -&amp;gt; 向右

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;题解&#34;&gt;题解&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	grid := [][]int{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}}
	len := uniquePathsWithObstacles(grid)
	fmt.Println(len)
}

func uniquePathsWithObstacles(obstacleGrid [][]int) int {
	n, m := len(obstacleGrid), len(obstacleGrid[0])
	f := make([]int, m)
	if obstacleGrid[0][0] == 0 {
		f[0] = 1
	}
	for i := 0; i &amp;lt; n; i++ {
		for j := 0; j &amp;lt; m; j++ {
			if obstacleGrid[i][j] == 1 {
				f[j] = 0
				continue
			}
			if j-1 &amp;gt;= 0 &amp;amp;&amp;amp; obstacleGrid[i][j-1] == 0 {
				f[j] += f[j-1]
			}
		}
	}
	return f[len(f)-1]
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ab压力测试</title>
      <link>https://yeqiongzhou.com/2020/07/apache-bench/</link>
      <pubDate>Wed, 22 Jul 2020 07:45:41 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/07/apache-bench/</guid>
      <description>

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;最近在工作中有这么一个需求：测试原子服务的 QPS 有多少，一种方式是用 Jenkins 跑压力测试，另一种就是今天要用的 apache bench (ab) 测试工具，ab 是用于对 Apache 超文本传输​​协议（HTTP）服务器进行基准测试的工具。&lt;/p&gt;

&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;

&lt;p&gt;ab 命令会创建多个并发访问线程，模拟多个访问者同时对某一 URL 地址进行访问。它的测试目标是基于 URL 的，因此，它既可以用来测试 apache 的负载压力，也可以测试 nginx、tomcat、IIS 等其它 web 服务器的压力。&lt;/p&gt;

&lt;h3 id=&#34;压力测试&#34;&gt;压力测试&lt;/h3&gt;

&lt;p&gt;这里就不展开讲 ab 的语法，直接讲 ab 进行压力测试的命令，详细语法大家可以参考&lt;a href=&#34;https://httpd.apache.org/docs/2.4/programs/ab.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ab官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在当前目录下新建 &lt;em&gt;post.json&lt;/em&gt; 文件存放 json 格式的请求
&lt;strong&gt;post.json&lt;/strong&gt;: {&amp;ldquo;data&amp;rdquo;:{&amp;ldquo;uri&amp;rdquo;:&amp;ldquo;&lt;a href=&#34;http://cdn.yeqiongzhou.top/pulp.jpg&amp;quot;}&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://cdn.yeqiongzhou.top/pulp.jpg&amp;quot;}&lt;/a&gt;}&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ab -n 6000 -c 60 -p post.json -T application/json -H &amp;ldquo;Authorization:xxx uid=xxx&amp;rdquo; &amp;ldquo;&lt;a href=&#34;http://12.34.56.78:1024/v1/ab&amp;quot;&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://12.34.56.78:1024/v1/ab&amp;quot;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面来详细介绍这条命令，让大家能够快速上手使用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-n 6000 代表测试 6000 次&lt;/li&gt;
&lt;li&gt;-c 60 代表模拟了 60 个客户端来请求相应的接口，也就是请求的并发数&lt;/li&gt;
&lt;li&gt;-p 包含了需要 post 的文件地址，和 -T 一起使用&lt;/li&gt;
&lt;li&gt;-H 请求头信息&lt;/li&gt;
&lt;li&gt;最后跟上要请求的接口地址&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Dockerfile多阶段构建</title>
      <link>https://yeqiongzhou.com/2020/07/docker-multistage-build/</link>
      <pubDate>Sun, 12 Jul 2020 23:33:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/07/docker-multistage-build/</guid>
      <description>

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;我们在构建docker镜像时，希望最后得到的镜像越小越好，但是在构建时，总是会用到各种各样复杂的环境，大部分都是临时环境，只是为了生成对应的目标程序。比如我们经常会在OpenCV环境下编译图像处理类程序，但其实目标程序只需要用的之前生成的子程序就行，不需要引入中间用到的环境。这里我们就能用到Dockerfile多阶段构建，它可以把前面多个阶段生成的文件拷贝到下一个阶段使用，并且不引入之前用到的环境，这极大地解耦了我们的Dockerfile文件，而且最终可以得到一个极小的完整镜像。&lt;/p&gt;

&lt;h3 id=&#34;多阶段构建&#34;&gt;多阶段构建&lt;/h3&gt;

&lt;p&gt;关于镜像构建，最重要的事情之一就是让镜像容量尽可能的变得更小，Dockerfile中的每条指令都会添加一层镜像，我们需要在进入下一层时清除之后用不到的文件。
在多阶段构建中，我们可以通过&lt;code&gt;FROM&lt;/code&gt;指令在Dockerfile中生成多个阶段。每个FROM指令可以使用不同的base镜像，并且每个指令都开始构建的新阶段，您可以把前一个阶段生成的文件COPY到另一个阶段，从而在最终的镜像中只留下需要的所有内容，下面通过一个例子来实践一下多阶段构建的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM golang:1.10.2
WORKDIR /go/src/github.com/yeqiongzhou/docker-multistage-build/
RUN go get -d -v golang.org/x/net/html
COPY app.go .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=0 /go/src/github.com/yeqiongzhou/docker-multistage-build/app .
CMD [&amp;quot;./app&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过build上面的Dockerfile文件，我们可以得到一个微型的镜像，第二条FROM指令以&lt;code&gt;alpine:latest&lt;/code&gt;镜像作为基础镜像开始新的构建阶段，&lt;code&gt;COPY --from=0&lt;/code&gt;命令可以将之前阶段的文件复制到这个新阶段。Golang SDK和其它临时文件都留在了第一个stage，没有保存到最终的镜像中，这极大的降低了Dockerfile的复杂度和减小了镜像的大小。&lt;/p&gt;

&lt;h3 id=&#34;多阶段构建的命名&#34;&gt;多阶段构建的命名&lt;/h3&gt;

&lt;p&gt;默认情况下，未命名的阶段，您可以通过其整数编号来引用它们，第一FROM条指令的起始编号为0。但是，您还可以通过&lt;code&gt;AS &amp;lt;NAME&amp;gt;&lt;/code&gt;在FROM指令中添加来命名阶段。下面的示例通过给阶段命名并在COPY指令中使用名称来引用前一个阶段的文件。这意味着，即使以后对Dockerfile中的指令进行了重新排序，它们也能正常的构建运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM golang:1.10.2 AS yeqiongzhou
WORKDIR /go/src/github.com/yeqiongzhou/docker-multistage-build/
COPY app.go .
RUN go get -d -v golang.org/x/net/html &amp;amp;&amp;amp; \
    CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=yeqiongzhou /go/src/github.com/yeqiongzhou/docker-multistage-build/app .
CMD [&amp;quot;./app&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;构建指定的阶段&#34;&gt;构建指定的阶段&lt;/h3&gt;

&lt;p&gt;构建映像时，不必构建整个Dockerfile，即所有的阶段。您可以指定目标构建阶段。以上面的Dockerfile为例，我们可以通过以下命令只构建第一个阶段。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;docker build &amp;ndash;target yeqiongzhou -t yeqiongzhou/docker-multistage-build:latest .
这个方法可以在调试测试阶段发挥很大的作用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;拷贝外部镜像的文件&#34;&gt;拷贝外部镜像的文件&lt;/h3&gt;

&lt;p&gt;使用多阶段构建时，您不仅可以之前在Dockerfile中创建的阶段进行拷贝。您可以使用&lt;code&gt;COPY --from&lt;/code&gt;指令从外部的镜像进行拷贝操作。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;COPY &amp;ndash;from=nginx:latest /etc/nginx/nginx.conf /nginx.conf&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;注&#34;&gt;注&lt;/h4&gt;

&lt;p&gt;Dockerfile中&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;运算符可以人为地将两个命令压缩在一起，以避免在镜像中创建额外的镜像层。另外如果命令比较长时不要忘记使用&lt;code&gt;\&lt;/code&gt;字符分隔命令行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mongo导出数据</title>
      <link>https://yeqiongzhou.com/2020/06/mongoexport/</link>
      <pubDate>Tue, 30 Jun 2020 23:55:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/06/mongoexport/</guid>
      <description>

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;最近工作上遇到一个需求，需要给算法人员导出某天某个用户所有的数据，这里就要用到mongoexport命令了。&lt;/p&gt;

&lt;h3 id=&#34;导出数据&#34;&gt;导出数据&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;mongoexport -h your-mongo-hostname &amp;ndash;port 27017 -d database-name -c collection-name -q &amp;lsquo;{&amp;ldquo;uid&amp;rdquo;:123456, &amp;ldquo;created_at&amp;rdquo;:{$gt:Date(1593446400000)}}&amp;rsquo; -o /home/yeqiongzhou/test.json&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;该命令可以通过查询条件导出指定用户(123456)在指定时间(2020-06-30)后的所有记录。&lt;/p&gt;

&lt;h4 id=&#34;tips&#34;&gt;Tips&lt;/h4&gt;

&lt;p&gt;-q选项可以指定查询条件，但是时间不支持ISODate格式，所以必须将时间转换为毫秒，可以通过&lt;code&gt;date -d 2020-06-30 +%s&lt;/code&gt;将ISODate格式的时间转换为时间戳，然后补上三个0转换为毫秒。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>视频拼接</title>
      <link>https://yeqiongzhou.com/2020/06/concatenate-video/</link>
      <pubDate>Tue, 30 Jun 2020 23:16:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/06/concatenate-video/</guid>
      <description>

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;最近在工作中有这么一个需求：用一个超大视频来测试一个视频服务接口，看结果响应是否超时。但是本地只有一个2GB大小的电影文件，如何快速生成一个10GB大小的视频文件。&lt;/p&gt;

&lt;h3 id=&#34;视频拼接&#34;&gt;视频拼接&lt;/h3&gt;

&lt;p&gt;FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源程序。本文就介绍&lt;a href=&#34;https://trac.ffmpeg.org/wiki/Concatenate&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;FFmpeg官方&lt;/a&gt;推荐的三种视频拼接方法.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Concat demuxer: 基于demuxer实现的拼接，需要视频音频的属性完全一样，这种方式不会对视频音频流解码再编码，因此速度很快，推荐大家使用这种方式。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -f concat -safe 0 -i filelist.txt -c copy yeqiongzhou.mp4
filelist.txt: file &#39;test1.mp4&#39;
              file &#39;test1.mp4&#39;
	      file &#39;test2.mp4&#39;
	      file &#39;test2.mp4&#39;
通过上面的命令我们就可以通过本地的test1.mp4和test2.mp4这两个小视频文件生成一个大视频文件。
Tips: 如果是相对路径，则不需要上面的-safe 0。
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Concat protocol: 该方式是基于文件来操作的，某些文件（例如MPEG-2 transport streams），这类似于在linux系统上使用cat命令或在Windows上进行复制操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;ffmpeg -i &amp;ldquo;concat:test1.mp4|test2.mp4|test3.mp4&amp;rdquo; -c copy yeqiongzhou.mp4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;Concat filter: 这种方式实际上是把所有的视频音频全部解码，统一为原始的音视频流，然后塞进编码器重新编码。这种方式需要视频之间的分辨率和帧率必须一致，优点是兼容性好，能够应付绝大部分场景。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -i test1.mp4 -i test2.webm -i test3.mov \
-filter_complex &amp;quot;[0✌️0][0🅰️0][1✌️0][1🅰️0][2✌️0][2🅰️0]concat=n=3:v=1:a=1[outv][outa]&amp;quot; \
-map &amp;quot;[outv]&amp;quot; -map &amp;quot;[outa]&amp;quot; yeqiongzhou.mkv
通过上面的命令我们合并了三个具有视频流和音频流的文件。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Linux chmod命令</title>
      <link>https://yeqiongzhou.com/2020/05/chmod/</link>
      <pubDate>Tue, 26 May 2020 23:35:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/05/chmod/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;命令详解&#34;&gt;命令详解&lt;/h2&gt;

&lt;p&gt;Linux/Unix 的文件调用权限分为三级: 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。
&lt;strong&gt;使用权限&lt;/strong&gt;: 所有使用者&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;chmod = change mode&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;chmod [-cfvR] [&amp;ndash;help] [&amp;ndash;version] mode file&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;p&gt;mode: 权限设定字串，格式如下 :
&amp;gt; [ugoa&amp;hellip;][[+-=][rwxX]&amp;hellip;][,&amp;hellip;]&lt;/p&gt;

&lt;p&gt;其中:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;u表示该文件的拥有者，g表示与该文件的拥有者属于同一个群体(group)者，o表示其他以外的人，a表示这三者皆是。&lt;/li&gt;
&lt;li&gt;+表示增加权限、-表示取消权限、=表示唯一设定权限。&lt;/li&gt;
&lt;li&gt;r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他参数说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-c: 若该文件权限确实已经更改，才显示其更改动作&lt;/li&gt;
&lt;li&gt;-f: 若该文件权限无法被更改也不要显示错误讯息&lt;/li&gt;
&lt;li&gt;-v: 显示权限变更的详细资料&lt;/li&gt;
&lt;li&gt;-R: 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)&lt;/li&gt;
&lt;li&gt;&amp;ndash;help: 显示辅助说明&lt;/li&gt;
&lt;li&gt;&amp;ndash;version: 显示版本&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;p&gt;1 将文件 yeqiongzhou.txt 设为所有人皆可读取:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chmod ugo+r yeqiongzhou.txt
chmod a+r yeqiongzhou.txt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2 将文件 yeqiongzhou.txt 与 xiaofang.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chmod ug+w,o-w yeqiongzhou.txt xiaofang.txt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3 将 yeqiongzhou.go 设定为只有该文件拥有者可以执行:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chmod u+x yeqiongzhou.go&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4 将目前目录下的所有文件与子目录皆设为任何人可读取:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chmod -R a+r *&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;5 此外chmod也可以用数字来表示权限如:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chmod 777 file
语法为: chmod abc file
其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;r=4，w=2，x=1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若要rwx属性则4+2+1=7；&lt;/li&gt;
&lt;li&gt;若要rw-属性则4+2=6；&lt;/li&gt;
&lt;li&gt;若要r-x属性则4+1=5。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;chmod a=rwx file&lt;/code&gt; 和 &lt;code&gt;chmod 777 file&lt;/code&gt; 效果相同
&lt;code&gt;chmod ug=rwx,o=x file&lt;/code&gt; 和 &lt;code&gt;chmod 771 file&lt;/code&gt; 效果相同&lt;/p&gt;

&lt;h4 id=&#34;注&#34;&gt;注&lt;/h4&gt;

&lt;p&gt;若用chmod 4755 filename可使此程序具有root的权限&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无重复字符的最长子串</title>
      <link>https://yeqiongzhou.com/2020/05/longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 25 May 2020 23:21:21 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/05/longest-substring-without-repeating-characters/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;

&lt;h3 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;输入: &amp;quot;abcabcbb&amp;quot;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;输入: &amp;quot;bbbbb&amp;quot;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;输入: &amp;quot;pwwkew&amp;quot;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;题解&#34;&gt;题解&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	str := []string{&amp;quot;abcabcbb&amp;quot;, &amp;quot;bbbbb&amp;quot;, &amp;quot;pwwkew&amp;quot;}
	for _, s := range str {
		len := lengthOfLongestSubstring(s)
		fmt.Println(len)
	}
}

func lengthOfLongestSubstring(s string) int {
	lastOccurred := make(map[byte]int)
	start := 0
	maxLength := 0
	for i, ch := range []byte(s) {
		if lastI, ok := lastOccurred[ch]; ok &amp;amp;&amp;amp; lastI &amp;gt;= start {
			start = lastI + 1
		}
		if i-start+1 &amp;gt; maxLength {
			maxLength = i - start + 1
		}
		lastOccurred[ch] = i
	}
	return maxLength
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Linux chgrp命令</title>
      <link>https://yeqiongzhou.com/2020/05/chgrp/</link>
      <pubDate>Mon, 25 May 2020 22:25:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/05/chgrp/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;命令详解&#34;&gt;命令详解&lt;/h2&gt;

&lt;p&gt;Linux chgrp命令用于变更文件或目录的所属群组。
在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;chgrp = change group&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;chgrp [-cfhRv][&amp;ndash;help][&amp;ndash;version][所属群组][文件或目录&amp;hellip;]
chgrp [-cfhRv][&amp;ndash;help][&amp;ndash;reference=&amp;lt;参考文件或目录&amp;gt;][&amp;ndash;version][文件或目录&amp;hellip;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;-c或&amp;ndash;changes 效果类似&amp;rdquo;-v&amp;rdquo;参数，但仅回报更改的部分。&lt;/li&gt;
&lt;li&gt;-f或&amp;ndash;quiet或&amp;ndash;silent 不显示错误信息。&lt;/li&gt;
&lt;li&gt;-h或&amp;ndash;no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。&lt;/li&gt;
&lt;li&gt;-R或&amp;ndash;recursive 递归处理，将指定目录下的所有文件及子目录一并处理。&lt;/li&gt;
&lt;li&gt;-v或&amp;ndash;verbose 显示指令执行过程。&lt;/li&gt;
&lt;li&gt;&amp;ndash;help 在线帮助。&lt;/li&gt;
&lt;li&gt;&amp;ndash;reference=&amp;lt;参考文件或目录&amp;gt;，把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。&lt;/li&gt;
&lt;li&gt;&amp;ndash;version 显示版本信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;改变文件的群组属性:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;chgrp -v bin yeqiongzhou.log&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bodhiye@yeqiongzhou ~/Desktop ll
-rw-r--r-- 1 bodhiye staff 0 May 25 22:05 yeqiongzhou.log
bodhiye@yeqiongzhou ~/Desktop chgrp -v bin yeqiongzhou.log
bodhiye@yeqiongzhou ~/Desktop ll
-rw-r--r-- 1 bodhiye bin 0 May 25 22:05 yeqiongzhou.log
可以看到将yeqiongzhou.log文件由staff群组改为了bin群组。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;根据指定文件改变文件的群组属性:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;chgrp &amp;ndash;reference=yeqiongzhou.log xiaofang.log&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bodhiye@yeqiongzhou ~/Desktop ll
-rw-r--r-- 1 bodhiye staff 0 May 25 22:22 xiaofang.log
-rw-r--r-- 1 bodhiye bin   0 May 25 22:05 yeqiongzhou.log
bodhiye@yeqiongzhou ~/Desktop chgrp --reference=yeqiongzhou.log xiaofang.log
bodhiye@yeqiongzhou ~/Desktop ll
-rw-r--r-- 1 bodhiye bin 0 May 25 22:22 xiaofang.log
-rw-r--r-- 1 bodhiye bin 0 May 25 22:05 yeqiongzhou.log
改变文件xiaofang.log 的群组属性，使得文件xiaofang.log的群组属性和参考文件yeqiongzhou.log的群组属性相同。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Docker部署Golang Http服务</title>
      <link>https://yeqiongzhou.com/2020/02/docker-golang-http/</link>
      <pubDate>Sun, 16 Feb 2020 11:31:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/02/docker-golang-http/</guid>
      <description>

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;最近在工作中有这么一个需求：由于某个服务只在生产环境下部署，测试环境下没有相关服务，但是本地无法访问生产环境的服务，所以我需要mock一个返回特定json的http服务。&lt;/p&gt;

&lt;h4 id=&#34;服务代码&#34;&gt;服务代码&lt;/h4&gt;

&lt;p&gt;相关代码已经上传至GitHub：&lt;a href=&#34;https://github.com/bodhiye/http-fake&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;https://github.com/bodhiye/http-fake&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;main.go代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
)

type fakeReq struct {
	URI string `json:&amp;quot;uri&amp;quot;`
}

// 处理application/json类型的POST请求
func fake(w http.ResponseWriter, r *http.Request) {
	// 根据请求body创建一个json解析器实例
	decoder := json.NewDecoder(r.Body)
	// 用于存放参数数据
	var req fakeReq
	// 解析参数 存入map
    decoder.Decode(&amp;amp;req)
    // 打印日志
	fmt.Printf(&amp;quot;url=%s\n&amp;quot;, req.URI)

    // 返回你需要的json，这里返回了{&amp;quot;code&amp;quot;: 200}
	fmt.Fprintf(w, `{&amp;quot;code&amp;quot;: 200}`)
}

func main() {
	http.HandleFunc(&amp;quot;/fake&amp;quot;, fake)
	http.ListenAndServe(&amp;quot;:2333&amp;quot;, nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dockerfile代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM golang:latest
MAINTAINER &amp;quot;yeqiongzhou@whu.edu.cn&amp;quot;
WORKDIR /go/src/http-fake
ADD . /go/src/http-fake
RUN go build .
EXPOSE 2333
ENTRYPOINT [&amp;quot;./http-fake&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;部署流程&#34;&gt;部署流程&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;编译Dockerfile文件：&lt;code&gt;docker build -t bodhiye/http-fake .&lt;/code&gt;编译完成后在终端输入&lt;code&gt;docker images&lt;/code&gt;可以查看刚才编译好的http-fake镜像。&lt;/li&gt;
&lt;li&gt;你得注册一个Docker Hub账号，注册成功后登录Docker Hub：&lt;code&gt;docker login -u bodhiye&lt;/code&gt;，之后输入密码即可登录成功。&lt;/li&gt;
&lt;li&gt;把镜像上传到Docker Hub：&lt;code&gt;docker push bodhiye/http-fake&lt;/code&gt;上传成功后可以在Docker Hub网站上看到刚刚上传的http-fake镜像。&lt;/li&gt;
&lt;li&gt;在你需要部署的服务器或者本地环境下拉取镜像：&lt;code&gt;docker pull bodhiye/http-fake:latest&lt;/code&gt;代码中latest表示拉取最新的镜像版本。&lt;/li&gt;
&lt;li&gt;启动http-fake服务：&lt;code&gt;docker run --name test-http -d -p 2048:2333 bodhiye/http-fake&lt;/code&gt;将容器服务内部的2333端口映射到本机的2048端口上，并给该容器服务起了一个my-test-http名称。&lt;/li&gt;
&lt;li&gt;测试http-fake服务：&lt;code&gt;curl -X POST -d &#39;{&amp;quot;uri&amp;quot;:&amp;quot;https://img.yeqiongzhou.com/test.jpg&amp;quot;}&#39; 127.0.0.1:2048/fake&lt;/code&gt;通过curl的方式来访问本地的http-fake服务，可以看到该服务返回了预期的json字段。如果要在本地访问服务器上的该服务，则127.0.0.1替换成服务器的IP地址。&lt;/li&gt;
&lt;li&gt;查看日志：&lt;code&gt;docker logs test-http&lt;/code&gt;可以打印出服务相关日志&lt;code&gt;url=https://img.yeqiongzhou.com/test.jpg&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Linux chattr命令</title>
      <link>https://yeqiongzhou.com/2019/12/chattr/</link>
      <pubDate>Wed, 18 Dec 2019 08:40:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/12/chattr/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;命令详解&#34;&gt;命令详解&lt;/h2&gt;

&lt;p&gt;chattr 命令用于改变文件属性。
这项指令可改变存放在 ext2 文件系统上的文件或目录属性，这些属性共有以下几种模式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a：append only，让文件或目录仅供附加用途，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件安全。&lt;/li&gt;
&lt;li&gt;A：no atime updates，不更新文件或目录的最后存取时间，文件或目录的 atime (access time)不可被修改(modified)。&lt;/li&gt;
&lt;li&gt;c：compressed，将文件或目录压缩后存放，设定文件是否经压缩后再存储，读取时需要经过自动解压操作将文件或目录压缩后存放。&lt;/li&gt;
&lt;li&gt;C：no copy-on-write (COW)，不执行写入时复制，多个调用者获取同一个资源，这时另一个调用者对这资源进行了修改，不生成一个副本。&lt;/li&gt;
&lt;li&gt;d：no dump，将文件或目录排除在倾倒操作之外，设定文件不能成为 dump 程序的备份目标。&lt;/li&gt;
&lt;li&gt;D：synchronous directory updates，同步更新目录。&lt;/li&gt;
&lt;li&gt;e：extent format，extent 格式。&lt;/li&gt;
&lt;li&gt;i：immutable，不得任意更动文件或目录，设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。&lt;/li&gt;
&lt;li&gt;j：data journaling，数据日志，文件在写入时会先被记录。&lt;/li&gt;
&lt;li&gt;s：secure deletion，保密性删除文件或目录，即硬盘空间被全部收回。&lt;/li&gt;
&lt;li&gt;S：synchronous updates，即时更新文件或目录，功能类似 sync。&lt;/li&gt;
&lt;li&gt;t：no tail-merging，文件系统支持尾部合并。&lt;/li&gt;
&lt;li&gt;T：top of directory hierarchy，具有该属性的目录将被视为目录层次结构的顶部。&lt;/li&gt;
&lt;li&gt;u：undeletable，预防意外删除，与s相反，当设定为u时，数据内容其实还存在磁盘中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;chattr = change attributes&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;chattr [-RVf] [-+=aAcCdDeijsStTu] [-v version] files&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;-R 递归处理，将指定目录下的所有文件及子目录一并处理。&lt;/li&gt;
&lt;li&gt;-v&amp;lt;版本编号&amp;gt; 设置文件或目录版本。&lt;/li&gt;
&lt;li&gt;-V 显示指令执行过程。&lt;/li&gt;
&lt;li&gt;+&amp;lt;属性&amp;gt; 开启文件或目录的该项属性。&lt;/li&gt;
&lt;li&gt;-&amp;lt;属性&amp;gt; 关闭文件或目录的该项属性。&lt;/li&gt;
&lt;li&gt;=&amp;lt;属性&amp;gt; 指定文件或目录的该项属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用 chattr 命令防止系统中某个关键文件被修改:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;chattr +i /root/yeqiongzhou.yaml&lt;br /&gt;
lsattr /root/yeqiongzhou.yaml&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;会显示如下属性: &lt;code&gt;----i-------- /root/yeqiongzhou.yaml&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;chattr +a /var/log/messages&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;注&#34;&gt;注&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;各参数选项中常用到的是a和i。a选项强制只可添加不可删除，多用于日志系统的安全设定。而i是更为严格的安全设定，只有superuser (root) 或具有 CAP_LINUX_IMMUTABLE 处理能力（标识）的进程能够施加该选项。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Linux cat命令</title>
      <link>https://yeqiongzhou.com/2019/12/cat/</link>
      <pubDate>Sun, 15 Dec 2019 23:45:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/12/cat/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;命令详解&#34;&gt;命令详解&lt;/h2&gt;

&lt;p&gt;cat 命令用于连接文件并打印到标准输出设备上。&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;cat = concatenate&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;cat [-AbeEnstTv] [&amp;ndash;help] [&amp;ndash;version] fileName&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;-n 或 &amp;ndash;number: 由1开始对所有输出的行数编号。&lt;/li&gt;
&lt;li&gt;-b 或 &amp;ndash;number-nonblank: 和 -n 相似，只不过对于空-不编号。&lt;/li&gt;
&lt;li&gt;-s 或 &amp;ndash;squeeze-blank: 当遇到有连续两行以上的空白行-代换为一行的空白行。&lt;/li&gt;
&lt;li&gt;-v 或 &amp;ndash;show-nonprinting: 使用 ^ 和 M- 符号，除了 -D 和 TAB 之外。&lt;/li&gt;
&lt;li&gt;-E 或 &amp;ndash;show-ends: 在每行结束处显示 $。&lt;/li&gt;
&lt;li&gt;-T 或 &amp;ndash;show-tabs: 将 TAB 字符显示为 ^I。&lt;/li&gt;
&lt;li&gt;-A 或 &amp;ndash;show-all: 等价于 -vET。&lt;/li&gt;
&lt;li&gt;-e: 等价于&amp;rdquo;-vE&amp;rdquo;选项。&lt;/li&gt;
&lt;li&gt;-t: 等价于&amp;rdquo;-vT&amp;rdquo;选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;cat -n textfile1 &amp;gt; textfile2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;cat -b textfile1 textfile2 &amp;gt;&amp;gt; textfile3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;清空 /etc/test.txt 文档内容:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;cat /dev/null &amp;gt; /etc/test.txt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;cat /dev/fd0 &amp;gt; OUTFILE&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;相反的，如果想把 image file 写到软盘，输入:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;cat IMG_FILE &amp;gt; /dev/fd0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;注&#34;&gt;注&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;在类 Unix 系统中，/dev/null 称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据，读取它则会立即得到一个 EOF。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes存活探针</title>
      <link>https://yeqiongzhou.com/2019/04/kubernetes-liveness-probes/</link>
      <pubDate>Fri, 19 Apr 2019 09:31:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/04/kubernetes-liveness-probes/</guid>
      <description>&lt;p&gt;　　Kubernetes可以通过存活探针（liveness probes）检查容器是否还在运行。可以为pod中的每个容器单独指定存活探针。如果探测失败，Kubernetes将定期执行探针并重新启动容器。&lt;/p&gt;

&lt;p&gt;　　Kubernetes有以下三种探测容器的机制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP GET探针对容器的IP地址（你指定的端口和路径）执行HTTP GET请求。如果探测器收到响应，并且响应状态码不代表错误（换句话说，如果HTTP响应状态码是2xx或3xx），则认为探测成功。如果服务器返回错误响应状态码或者根本没有响应，那么探测就被认为是失败的，容器将被重新启动。&lt;/li&gt;
&lt;li&gt;TCP套接字探针尝试与容器指定端口建立TCP连接。如果连接成功建立，则探测成功。否则，容器重新启动。&lt;/li&gt;
&lt;li&gt;Exec探针在容器内执行任意命令，并检查命令的退出状态码。如果状态码是0，则探测成功。所有其他状态码都被认为失败。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>