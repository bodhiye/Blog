<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>叶琼州的代码小窝 on 叶琼州的代码小窝</title>
    <link>https://yeqiongzhou.com/</link>
    <description>Recent content in 叶琼州的代码小窝 on 叶琼州的代码小窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 16 Aug 2020 17:13:14 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux file命令</title>
      <link>https://yeqiongzhou.com/2020/08/file/</link>
      <pubDate>Sun, 16 Aug 2020 17:13:14 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/08/file/</guid>
      <description>

&lt;hr /&gt;

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;Linux 中“一切皆文件”，任何事物都是以文件的形式存在，在 windows 环境下，我们一般情况下可以通过文件的后缀名来识别文件的种类，但是在 linux 环境下，文件名可以自由更改，这时我们就可以通过 file 命令来获取文件的类型信息。&lt;/p&gt;

&lt;h3 id=&#34;命令详解&#34;&gt;命令详解&lt;/h3&gt;

&lt;p&gt;Linux file 命令用于辨识文件类型，通过 file 指令，我们得以辨识该文件的类型。&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;file [-bcLvz][-f &amp;lt;名称文件&amp;gt;][-m &amp;lt;魔法数字文件&amp;gt;&amp;hellip;][文件或目录&amp;hellip;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;-b 　列出辨识结果时，不显示文件名称。&lt;/li&gt;
&lt;li&gt;-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。&lt;/li&gt;
&lt;li&gt;-f&amp;lt;名称文件&amp;gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。&lt;/li&gt;
&lt;li&gt;-i 　显示MIME类别。&lt;/li&gt;
&lt;li&gt;-L 　直接显示符号连接所指向的文件的类别。&lt;/li&gt;
&lt;li&gt;-m&amp;lt;魔法数字文件&amp;gt; 　指定魔法数字文件。&lt;/li&gt;
&lt;li&gt;-v 　显示版本信息。&lt;/li&gt;
&lt;li&gt;-z 　尝试去解读压缩文件的内容。&lt;/li&gt;
&lt;li&gt;[文件或目录&amp;hellip;]  要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;p&gt;1、显示文件类型：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;file yetalks.mp4&lt;br /&gt;
yetalks.mp4: ISO Media, MP4 v2 [ISO 14496-14]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2、不显示文件名称：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;file -b yetalks.mp4&lt;br /&gt;
ISO Media, MP4 v2 [ISO 14496-14]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3、显示MIME类别：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;file -i yetalks.log&lt;br /&gt;
yetalks.log: text/plain; charset=utf-8&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;

&lt;p&gt;Linux 一切皆文件。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux diff命令</title>
      <link>https://yeqiongzhou.com/2020/08/diff/</link>
      <pubDate>Wed, 12 Aug 2020 23:48:09 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/08/diff/</guid>
      <description>

&lt;hr /&gt;

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;Linux 中比较两个文件是否一致有好几种方式，前面已经讲过了 cksum 命令来校验两个文件是否一致，还讲了利用 cmp 来比较两个文件是否有差异，今天来讲一下另一个比较文件差异的 diff 命令。&lt;/p&gt;

&lt;h3 id=&#34;命令详解&#34;&gt;命令详解&lt;/h3&gt;

&lt;p&gt;Linux diff 命令用于比较文件的差异。
diff 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;diff = Difference&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;diff [-abBcdefHilnNpPqrstTuvwy][-&amp;lt;行数&amp;gt;][-C &amp;lt;行数&amp;gt;][-D &amp;lt;巨集名称&amp;gt;][-I &amp;lt;字符或字符串&amp;gt;][-S &amp;lt;文件&amp;gt;][-W &amp;lt;宽度&amp;gt;][-x &amp;lt;文件或目录&amp;gt;][-X &amp;lt;文件&amp;gt;][&amp;ndash;help][&amp;ndash;left-column][&amp;ndash;suppress-common-line][文件或目录1][文件或目录2]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;-&amp;lt;行数&amp;gt;: 指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。&lt;/li&gt;
&lt;li&gt;-a或&amp;ndash;text: diff预设只会逐行比较文本文件。&lt;/li&gt;
&lt;li&gt;-b或&amp;ndash;ignore-space-change: 不检查空格字符的不同。&lt;/li&gt;
&lt;li&gt;-B或&amp;ndash;ignore-blank-lines: 不检查空白行。&lt;/li&gt;
&lt;li&gt;-c: 显示全部内文，并标出不同之处。&lt;/li&gt;
&lt;li&gt;-C&amp;lt;行数&amp;gt;或&amp;ndash;context&amp;lt;行数&amp;gt;: 与执行&amp;rdquo;-c-&amp;lt;行数&amp;gt;&amp;ldquo;指令相同。&lt;/li&gt;
&lt;li&gt;-d或&amp;ndash;minimal: 使用不同的演算法，以较小的单位来做比较。&lt;/li&gt;
&lt;li&gt;-D&amp;lt;巨集名称&amp;gt;或ifdef&amp;lt;巨集名称&amp;gt;: 此参数的输出格式可用于前置处理器巨集。&lt;/li&gt;
&lt;li&gt;-e或&amp;ndash;ed: 此参数的输出格式可用于ed的script文件。&lt;/li&gt;
&lt;li&gt;-f或-forward-ed: 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。&lt;/li&gt;
&lt;li&gt;-H或&amp;ndash;speed-large-files: 比较大文件时，可加快速度。&lt;/li&gt;
&lt;li&gt;-l&amp;lt;字符或字符串&amp;gt;或&amp;ndash;ignore-matching-lines&amp;lt;字符或字符串&amp;gt;: 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。&lt;/li&gt;
&lt;li&gt;-i或&amp;ndash;ignore-case: 不检查大小写的不同。&lt;/li&gt;
&lt;li&gt;-l或&amp;ndash;paginate: 将结果交由pr程序来分页。&lt;/li&gt;
&lt;li&gt;-n或&amp;ndash;rcs: 将比较结果以RCS的格式来显示。&lt;/li&gt;
&lt;li&gt;-N或&amp;ndash;new-file: 在比较目录时，若文件A仅出现在某个目录中，预设会显示：&lt;/li&gt;
&lt;li&gt;Only in目录: 件A若使用-N参数，则diff会将文件A与一个空白的文件比较。&lt;/li&gt;
&lt;li&gt;-p: 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。&lt;/li&gt;
&lt;li&gt;-P或&amp;ndash;unidirectional-new-file: 与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。&lt;/li&gt;
&lt;li&gt;-q或&amp;ndash;brief: 仅显示有无差异，不显示详细的信息。&lt;/li&gt;
&lt;li&gt;-r或&amp;ndash;recursive: 比较子目录中的文件。&lt;/li&gt;
&lt;li&gt;-s或&amp;ndash;report-identical-files: 若没有发现任何差异，仍然显示信息。&lt;/li&gt;
&lt;li&gt;-S&amp;lt;文件&amp;gt;或&amp;ndash;starting-file&amp;lt;文件&amp;gt;: 在比较目录时，从指定的文件开始比较。&lt;/li&gt;
&lt;li&gt;-t或&amp;ndash;expand-tabs: 在输出时，将tab字符展开。&lt;/li&gt;
&lt;li&gt;-T或&amp;ndash;initial-tab: 在每行前面加上tab字符以便对齐。&lt;/li&gt;
&lt;li&gt;-u,-U&amp;lt;列数&amp;gt;或&amp;ndash;unified=&amp;lt;列数&amp;gt;: 以合并的方式来显示文件内容的不同。&lt;/li&gt;
&lt;li&gt;-v或&amp;ndash;version: 显示版本信息。&lt;/li&gt;
&lt;li&gt;-w或&amp;ndash;ignore-all-space: 忽略全部的空格字符。&lt;/li&gt;
&lt;li&gt;-W&amp;lt;宽度&amp;gt;或&amp;ndash;width&amp;lt;宽度&amp;gt;: 在使用-y参数时，指定栏宽。&lt;/li&gt;
&lt;li&gt;-x&amp;lt;文件名或目录&amp;gt;或&amp;ndash;exclude&amp;lt;文件名或目录&amp;gt;: 不比较选项中所指定的文件或目录。&lt;/li&gt;
&lt;li&gt;-X&amp;lt;文件&amp;gt;或&amp;ndash;exclude-from&amp;lt;文件&amp;gt;: 您可以将文件或目录类型存成文本文件，然后在=&amp;lt;文件&amp;gt;中指定此文本文件。&lt;/li&gt;
&lt;li&gt;-y或&amp;ndash;side-by-side: 以并列的方式显示文件的异同之处。&lt;/li&gt;
&lt;li&gt;&amp;ndash;help: 显示帮助。&lt;/li&gt;
&lt;li&gt;&amp;ndash;left-column: 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。&lt;/li&gt;
&lt;li&gt;&amp;ndash;suppress-common-lines: 在使用-y参数时，仅显示不同之处。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;p&gt;上面看了一大堆参数，下面来看看 diff 命令的实际使用吧，首先准备两个文件 xiaoye.log 和 xiaofang.log，接着来比较这两个文件：
xiaoye.log&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;yeqiongzhou
region
shanghai
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;xiaofang.log&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;xiaofang
region
china
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;diff xiaoye.log xiaofang.log&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;1c1
&amp;lt; yeqiongzhou
---
&amp;gt; xiaofang
3c3
&amp;lt; shanghai
---
&amp;gt; china
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的&amp;rdquo;1c1&amp;rdquo;和&amp;rdquo;3c3&amp;rdquo;表示 xiaoye.log 和 xiaofang.log 文件在第1行和第3行内容有所不同。&lt;/p&gt;

&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&amp;rdquo;|&amp;rdquo; 表示前后两个文件内容有不同。&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&amp;lt;&amp;rdquo; 表示后面文件比前面文件少了一行内容。&lt;/li&gt;
&lt;li&gt;&amp;rdquo;&amp;gt;&amp;rdquo; 表示后面文件比前面文件多了一行内容。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Linux cmp命令</title>
      <link>https://yeqiongzhou.com/2020/08/cmp/</link>
      <pubDate>Mon, 10 Aug 2020 23:07:56 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/08/cmp/</guid>
      <description>

&lt;hr /&gt;

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;Linux 中比较两个文件是否一致有好几种方式，前面已经讲过了 cksum 命令来校验两个文件是否一致，今天来讲一下 cmp 命令。&lt;/p&gt;

&lt;h3 id=&#34;命令详解&#34;&gt;命令详解&lt;/h3&gt;

&lt;p&gt;Linux cmp 命令用于比较两个文件是否有差异。当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有所差异，预设会标示出第一个不同之处的字符和列数编号。若不指定任何文件名称或是所给予的文件名为&amp;rdquo;-&amp;ldquo;，则 cmp 指令会从标准输入设备读取数据。&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;cmp = compare&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;cmp [-clsv][-i &amp;lt;字符数目&amp;gt;][&amp;ndash;help][第一个文件][第二个文件]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;-c或&amp;ndash;print-chars: 除了标明差异处的十进制字码之外，一并显示该字符所对应字符。&lt;/li&gt;
&lt;li&gt;-i&amp;lt;字符数目&amp;gt;或&amp;ndash;ignore-initial=&amp;lt;字符数目&amp;gt;: 指定一个数目。&lt;/li&gt;
&lt;li&gt;-l或&amp;ndash;verbose: 标示出所有不一样的地方。&lt;/li&gt;
&lt;li&gt;-s或&amp;ndash;quiet或&amp;ndash;silent: 不显示错误信息。&lt;/li&gt;
&lt;li&gt;-v或&amp;ndash;version: 显示版本信息。&lt;/li&gt;
&lt;li&gt;&amp;ndash;help: 在线帮助。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;p&gt;1、要确定两个文件是否相同，请输入：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;cmp yeqiongzhou.jpg yeqiongzhou.jpg.bak&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面命令比较 yeqiongzhou.jpg 和 yeqiongzhou.jpg.bak 是否相同。如果文件相同，则不显示消息。&lt;/p&gt;

&lt;p&gt;2、如果比较的两个文件不同，则显示第一个不同的位置，例如：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;cmp yeqiongzhou1.jpg yeqiongzhou2.jpg&lt;br /&gt;
yeqiongzhou1.jpg yeqiongzhou2.jpg differ: char 22, line 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;

&lt;p&gt;如果显示消息 cmp: EOF on yeqiongzhou1.jpg，则 yeqiongzhou2.jpg 的第一部分与 yeqiongzhou1.jpg 相同，但在 yeqiongzhou2.jpg 中还有其他数据。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux chown命令</title>
      <link>https://yeqiongzhou.com/2020/08/chown/</link>
      <pubDate>Sun, 09 Aug 2020 22:44:22 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/08/chown/</guid>
      <description>

&lt;hr /&gt;

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。&lt;/p&gt;

&lt;h3 id=&#34;命令详解&#34;&gt;命令详解&lt;/h3&gt;

&lt;p&gt;chown 命令，主要用于修改文件（或目录）的所有者，除此之外，这个命令也可以修改文件（或目录）的所属组。&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;chown = change owner&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;chown [-cfhvR] [&amp;ndash;help] [&amp;ndash;version] user[:group] file&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;user : 新的文件拥有者的使用者 ID&lt;/li&gt;
&lt;li&gt;group : 新的文件拥有者的使用者组(group)&lt;/li&gt;
&lt;li&gt;-c : 显示更改的部分的信息&lt;/li&gt;
&lt;li&gt;-f : 忽略错误信息&lt;/li&gt;
&lt;li&gt;-h :修复符号链接&lt;/li&gt;
&lt;li&gt;-v : 显示详细的处理信息&lt;/li&gt;
&lt;li&gt;-R : 处理指定目录以及其子目录下的所有文件&lt;/li&gt;
&lt;li&gt;&amp;ndash;help : 显示辅助说明&lt;/li&gt;
&lt;li&gt;&amp;ndash;version : 显示版本&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;p&gt;1、将文件 yeqiongzhou.jpg 的拥有者设为 bodhiye，群体的使用者 xiaoye:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chown bodhiye:xiaoye yeqiongzhou.jpg&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2、将目前目录下的所有文件与子目录的拥有者皆设为 bodhiye，群体的使用者 xiaoye:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chown -R bodhiye:xiaoye *&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3、chown 命令也支持单纯的修改文件或目录的所属组：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chown :xiaoye yeqiongzhou.jpg&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就表示修改 yeqiongzhou.jpg 文件的所属组为 xiaoye，但修改所属组通常使用 chgrp 命令，因此只修改文件所属组时并不推荐大家使用 chown 命令。&lt;/p&gt;

&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;

&lt;p&gt;一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限把自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux nohup命令</title>
      <link>https://yeqiongzhou.com/2020/08/nohup/</link>
      <pubDate>Mon, 03 Aug 2020 23:03:22 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/08/nohup/</guid>
      <description>

&lt;hr /&gt;

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;我们平时在远程服务器或者跳板机上执行命令时，如果由于长时间未操作导致服务端未响应，触发了防火墙的闲置超时断开的缺省机制，会导致之前执行的命令中断。&lt;/p&gt;

&lt;h3 id=&#34;命令详解&#34;&gt;命令详解&lt;/h3&gt;

&lt;p&gt;nohup 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。&lt;/p&gt;

&lt;p&gt;nohup命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录文件不可写，则输出重定向到 $HOME/nohup.out 文件中。&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;cksum = no hang up&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;nohup Command [ Arg … ] [　&amp;amp; ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Command：要执行的命令。&lt;/li&gt;
&lt;li&gt;Arg：一些参数，可以指定输出文件。&lt;/li&gt;
&lt;li&gt;&amp;amp;：让命令在后台执行，终端退出后命令仍旧执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;p&gt;1、以下命令在后台执行 root 目录下的 yeqiongzhou.sh 脚本：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;nohup /root/yeqiongzhou.sh &amp;amp;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上命令执行后，在终端如果看到以下输出说明运行成功：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;nohup: ignoring input and appending output to &amp;lsquo;nohup.out&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这时我们打开 root 目录 可以看到生存了 nohup.out 文件。
如果要停止运行，你需要使用以下命令查找到 nohup 运行脚本到 PID，然后使用 kill 命令来删除。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ps -aux | grep &amp;ldquo;yeqiongzhou.sh&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;找到 PID 后，就可以使用 kill PID 来删除该后台进程。&lt;/p&gt;

&lt;p&gt;2、以下命令在后台执行 root 目录下的 yeqiongzhou.sh 脚本，并重定向输入到 yeqiongzhou.log 文件：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;nohup /root/test.sh &amp;gt; yeqiongzhou.log 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;2&amp;gt;&amp;amp;1&lt;/strong&gt;：将标准错误 2 重定向到标准输出 &amp;amp;1 ，标准输出 &amp;amp;1 再被重定向输入到 runoob.log 文件中。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0 – stdin (standard input，标准输入)&lt;/li&gt;
&lt;li&gt;1 – stdout (standard output，标准输出)&lt;/li&gt;
&lt;li&gt;2 – stderr (standard error，标准错误输出)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>不同路径</title>
      <link>https://yeqiongzhou.com/2020/07/unique-paths/</link>
      <pubDate>Thu, 30 Jul 2020 00:23:29 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/07/unique-paths/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;一个机器人位于一个 m x n 网格的左上角（起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.yeqiongzhou.com/unique-paths-ii.jpg&#34; alt=&#34;不同路径&#34; /&gt;&lt;/p&gt;

&lt;p&gt;例如，上图是一个 7 x 3 的网格，有多少可能的路径？&lt;/p&gt;

&lt;h3 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;输入: m = 3, n = 2
输出: 3
解释: 从左上角开始，总共有 3 条路径可以到达右下角。

1. 向右 -&amp;gt; 向右 -&amp;gt; 向下
2. 向右 -&amp;gt; 向下 -&amp;gt; 向右
3. 向下 -&amp;gt; 向右 -&amp;gt; 向右

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;输入: m = 7, n = 3
输出: 28
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;提示&#34;&gt;提示&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= m, n &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;题目数据保证答案小于等于 2 * 10 ^ 9&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;题解&#34;&gt;题解&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	len := uniquePaths(2,3)
	fmt.Println(len)
}

func uniquePaths(m, n int) int {
	f := make([]int, m)
	f[0] = 1
	for i := 0; i &amp;lt; n; i++ {
		for j := 0; j &amp;lt; m; j++ {
			if j-1 &amp;gt;= 0 {
				f[j] += f[j-1]
			}
		}
	}
	return f[len(f)-1]
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Linux cksum命令</title>
      <link>https://yeqiongzhou.com/2020/07/cksum/</link>
      <pubDate>Wed, 29 Jul 2020 23:25:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/07/cksum/</guid>
      <description>

&lt;hr /&gt;

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;最近女朋友要我把相机里旅游时拍的照片发给她，然后我就把照片传到百度云发给她了，她下载后就抱怨说百度云把图片压缩了，导致图片放大后看不清，我马上上百度云看了一下，发现文件大小没有压缩，于是我就把百度云下载的图片和我本地内存卡里的照片比对一下，看百度云是否把我的图片压缩了。这里就可以用到 cksum 命令来检查两个文件是否一致。&lt;/p&gt;

&lt;h3 id=&#34;命令详解&#34;&gt;命令详解&lt;/h3&gt;

&lt;p&gt;Linux cksum 命令用于检查文件的 CRC（Cyclic Redundancy Check 循环冗余检验码）是否正确，确保文件从一个系统传输到另一个系统的过程中不被损坏。&lt;/p&gt;

&lt;p&gt;CRC 是一种排错检查方式，该校验法的标准由 CCITT 所指定，至少可检测到 99.998% 的已知错误。&lt;/p&gt;

&lt;p&gt;指定文件交由指令&amp;rdquo;cksum&amp;rdquo;进行校验后，该指令会返回校验结果供用户核对文件是否正确无误。若不指定任何文件名称或是所给予的文件名为&amp;rdquo;-&amp;ldquo;，则指令&amp;rdquo;cksum&amp;rdquo;会从标准输入设备中读取数据。&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;cksum = checksums&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;cksum [&amp;ndash;help][&amp;ndash;version][文件&amp;hellip;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ndash;help：在线帮助。&lt;/li&gt;
&lt;li&gt;&amp;ndash;version：显示版本信息。&lt;/li&gt;
&lt;li&gt;文件…:需要进行检查的文件路径&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;p&gt;使用指令&amp;rdquo;cksum&amp;rdquo;计算文件 yeqiongzhou.jpg 和 yeqiongzhou-baiduyun.jpg 的一致性，输入如下命令：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;cksum yeqiongzhou.jpg yeqiongzhou-baiduyun.jpg&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上命令执行后，将输出校验码等相关的信息，具体输出信息如下所示：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2415123943 3538944 yeqiongzhou.jpg&lt;br /&gt;
2415123943 3538944 yeqiongzhou-baiduyun.jpg&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面的输出信息中，&lt;code&gt;2415123943&lt;/code&gt;表示校验码，&lt;code&gt;3538944&lt;/code&gt;表示字节数。
可见这两张图片是一模一样的，百度云并没有对照片进行压缩。&lt;/p&gt;

&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;

&lt;p&gt;如果文件中有任何字符被修改，都将改变计算后 CRC 校验码的值。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>不同路径II</title>
      <link>https://yeqiongzhou.com/2020/07/unique-paths-ii/</link>
      <pubDate>Sun, 26 Jul 2020 10:21:21 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/07/unique-paths-ii/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;一个机器人位于一个 m x n 网格的左上角（起始点在下图中标记为“Start”）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.yeqiongzhou.com/unique-paths-ii.jpg&#34; alt=&#34;不同路径II&#34; /&gt;&lt;/p&gt;

&lt;p&gt;网格中的障碍物和空位置分别用 1 和 0 来表示。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;m 和 n 的值均不超过 100。&lt;/p&gt;

&lt;h3 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：

1. 向右 -&amp;gt; 向右 -&amp;gt; 向下 -&amp;gt; 向下
2. 向下 -&amp;gt; 向下 -&amp;gt; 向右 -&amp;gt; 向右

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;题解&#34;&gt;题解&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	grid := [][]int{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}}
	len := uniquePathsWithObstacles(grid)
	fmt.Println(len)
}

func uniquePathsWithObstacles(obstacleGrid [][]int) int {
	n, m := len(obstacleGrid), len(obstacleGrid[0])
	f := make([]int, m)
	if obstacleGrid[0][0] == 0 {
		f[0] = 1
	}
	for i := 0; i &amp;lt; n; i++ {
		for j := 0; j &amp;lt; m; j++ {
			if obstacleGrid[i][j] == 1 {
				f[j] = 0
				continue
			}
			if j-1 &amp;gt;= 0 &amp;amp;&amp;amp; obstacleGrid[i][j-1] == 0 {
				f[j] += f[j-1]
			}
		}
	}
	return f[len(f)-1]
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ab压力测试</title>
      <link>https://yeqiongzhou.com/2020/07/apache-bench/</link>
      <pubDate>Wed, 22 Jul 2020 07:45:41 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/07/apache-bench/</guid>
      <description>

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;最近在工作中有这么一个需求：测试原子服务的 QPS 有多少，一种方式是用 Jenkins 跑压力测试，另一种就是今天要用的 apache bench (ab) 测试工具，ab 是用于对 Apache 超文本传输​​协议（HTTP）服务器进行基准测试的工具。&lt;/p&gt;

&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;

&lt;p&gt;ab 命令会创建多个并发访问线程，模拟多个访问者同时对某一 URL 地址进行访问。它的测试目标是基于 URL 的，因此，它既可以用来测试 apache 的负载压力，也可以测试 nginx、tomcat、IIS 等其它 web 服务器的压力。&lt;/p&gt;

&lt;h3 id=&#34;压力测试&#34;&gt;压力测试&lt;/h3&gt;

&lt;p&gt;这里就不展开讲 ab 的语法，直接讲 ab 进行压力测试的命令，详细语法大家可以参考&lt;a href=&#34;https://httpd.apache.org/docs/2.4/programs/ab.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ab官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在当前目录下新建 &lt;em&gt;post.json&lt;/em&gt; 文件存放 json 格式的请求
&lt;strong&gt;post.json&lt;/strong&gt;: {&amp;ldquo;data&amp;rdquo;:{&amp;ldquo;uri&amp;rdquo;:&amp;ldquo;&lt;a href=&#34;http://cdn.yeqiongzhou.com/pulp.jpg&amp;quot;}&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://cdn.yeqiongzhou.com/pulp.jpg&amp;quot;}&lt;/a&gt;}&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ab -n 6000 -c 60 -p post.json -T application/json -H &amp;ldquo;Authorization:xxx uid=xxx&amp;rdquo; &amp;ldquo;&lt;a href=&#34;http://12.34.56.78:1024/v1/ab&amp;quot;&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://12.34.56.78:1024/v1/ab&amp;quot;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面来详细介绍这条命令，让大家能够快速上手使用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-n 6000 代表测试 6000 次&lt;/li&gt;
&lt;li&gt;-c 60 代表模拟了 60 个客户端来请求相应的接口，也就是请求的并发数&lt;/li&gt;
&lt;li&gt;-p 包含了需要 post 的文件地址，和 -T 一起使用&lt;/li&gt;
&lt;li&gt;-H 请求头信息&lt;/li&gt;
&lt;li&gt;最后跟上要请求的接口地址&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Dockerfile多阶段构建</title>
      <link>https://yeqiongzhou.com/2020/07/docker-multistage-build/</link>
      <pubDate>Sun, 12 Jul 2020 23:33:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/07/docker-multistage-build/</guid>
      <description>

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;我们在构建docker镜像时，希望最后得到的镜像越小越好，但是在构建时，总是会用到各种各样复杂的环境，大部分都是临时环境，只是为了生成对应的目标程序。比如我们经常会在OpenCV环境下编译图像处理类程序，但其实目标程序只需要用的之前生成的子程序就行，不需要引入中间用到的环境。这里我们就能用到Dockerfile多阶段构建，它可以把前面多个阶段生成的文件拷贝到下一个阶段使用，并且不引入之前用到的环境，这极大地解耦了我们的Dockerfile文件，而且最终可以得到一个极小的完整镜像。&lt;/p&gt;

&lt;h3 id=&#34;多阶段构建&#34;&gt;多阶段构建&lt;/h3&gt;

&lt;p&gt;关于镜像构建，最重要的事情之一就是让镜像容量尽可能的变得更小，Dockerfile中的每条指令都会添加一层镜像，我们需要在进入下一层时清除之后用不到的文件。
在多阶段构建中，我们可以通过&lt;code&gt;FROM&lt;/code&gt;指令在Dockerfile中生成多个阶段。每个FROM指令可以使用不同的base镜像，并且每个指令都开始构建的新阶段，您可以把前一个阶段生成的文件COPY到另一个阶段，从而在最终的镜像中只留下需要的所有内容，下面通过一个例子来实践一下多阶段构建的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM golang:1.10.2
WORKDIR /go/src/github.com/yeqiongzhou/docker-multistage-build/
RUN go get -d -v golang.org/x/net/html
COPY app.go .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=0 /go/src/github.com/yeqiongzhou/docker-multistage-build/app .
CMD [&amp;quot;./app&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过build上面的Dockerfile文件，我们可以得到一个微型的镜像，第二条FROM指令以&lt;code&gt;alpine:latest&lt;/code&gt;镜像作为基础镜像开始新的构建阶段，&lt;code&gt;COPY --from=0&lt;/code&gt;命令可以将之前阶段的文件复制到这个新阶段。Golang SDK和其它临时文件都留在了第一个stage，没有保存到最终的镜像中，这极大的降低了Dockerfile的复杂度和减小了镜像的大小。&lt;/p&gt;

&lt;h3 id=&#34;多阶段构建的命名&#34;&gt;多阶段构建的命名&lt;/h3&gt;

&lt;p&gt;默认情况下，未命名的阶段，您可以通过其整数编号来引用它们，第一FROM条指令的起始编号为0。但是，您还可以通过&lt;code&gt;AS &amp;lt;NAME&amp;gt;&lt;/code&gt;在FROM指令中添加来命名阶段。下面的示例通过给阶段命名并在COPY指令中使用名称来引用前一个阶段的文件。这意味着，即使以后对Dockerfile中的指令进行了重新排序，它们也能正常的构建运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM golang:1.10.2 AS yeqiongzhou
WORKDIR /go/src/github.com/yeqiongzhou/docker-multistage-build/
COPY app.go .
RUN go get -d -v golang.org/x/net/html &amp;amp;&amp;amp; \
    CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=yeqiongzhou /go/src/github.com/yeqiongzhou/docker-multistage-build/app .
CMD [&amp;quot;./app&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;构建指定的阶段&#34;&gt;构建指定的阶段&lt;/h3&gt;

&lt;p&gt;构建映像时，不必构建整个Dockerfile，即所有的阶段。您可以指定目标构建阶段。以上面的Dockerfile为例，我们可以通过以下命令只构建第一个阶段。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;docker build &amp;ndash;target yeqiongzhou -t yeqiongzhou/docker-multistage-build:latest .
这个方法可以在调试测试阶段发挥很大的作用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;拷贝外部镜像的文件&#34;&gt;拷贝外部镜像的文件&lt;/h3&gt;

&lt;p&gt;使用多阶段构建时，您不仅可以之前在Dockerfile中创建的阶段进行拷贝。您可以使用&lt;code&gt;COPY --from&lt;/code&gt;指令从外部的镜像进行拷贝操作。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;COPY &amp;ndash;from=nginx:latest /etc/nginx/nginx.conf /nginx.conf&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;注&#34;&gt;注&lt;/h4&gt;

&lt;p&gt;Dockerfile中&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;运算符可以人为地将两个命令压缩在一起，以避免在镜像中创建额外的镜像层。另外如果命令比较长时不要忘记使用&lt;code&gt;\&lt;/code&gt;字符分隔命令行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mongo导出数据</title>
      <link>https://yeqiongzhou.com/2020/06/mongoexport/</link>
      <pubDate>Tue, 30 Jun 2020 23:55:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/06/mongoexport/</guid>
      <description>

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;最近工作上遇到一个需求，需要给算法人员导出某天某个用户所有的数据，这里就要用到mongoexport命令了。&lt;/p&gt;

&lt;h3 id=&#34;导出数据&#34;&gt;导出数据&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;mongoexport -h your-mongo-hostname &amp;ndash;port 27017 -d database-name -c collection-name -q &amp;lsquo;{&amp;ldquo;uid&amp;rdquo;:123456, &amp;ldquo;created_at&amp;rdquo;:{$gt:Date(1593446400000)}}&amp;rsquo; -o /home/yeqiongzhou/test.json&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;该命令可以通过查询条件导出指定用户(123456)在指定时间(2020-06-30)后的所有记录。&lt;/p&gt;

&lt;h4 id=&#34;tips&#34;&gt;Tips&lt;/h4&gt;

&lt;p&gt;-q选项可以指定查询条件，但是时间不支持ISODate格式，所以必须将时间转换为毫秒，可以通过&lt;code&gt;date -d 2020-06-30 +%s&lt;/code&gt;将ISODate格式的时间转换为时间戳，然后补上三个0转换为毫秒。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>视频拼接</title>
      <link>https://yeqiongzhou.com/2020/06/concatenate-video/</link>
      <pubDate>Tue, 30 Jun 2020 23:16:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/06/concatenate-video/</guid>
      <description>

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;最近在工作中有这么一个需求：用一个超大视频来测试一个视频服务接口，看结果响应是否超时。但是本地只有一个2GB大小的电影文件，如何快速生成一个10GB大小的视频文件。&lt;/p&gt;

&lt;h3 id=&#34;视频拼接&#34;&gt;视频拼接&lt;/h3&gt;

&lt;p&gt;FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源程序。本文就介绍&lt;a href=&#34;https://trac.ffmpeg.org/wiki/Concatenate&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;FFmpeg官方&lt;/a&gt;推荐的三种视频拼接方法.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Concat demuxer: 基于demuxer实现的拼接，需要视频音频的属性完全一样，这种方式不会对视频音频流解码再编码，因此速度很快，推荐大家使用这种方式。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -f concat -safe 0 -i filelist.txt -c copy yeqiongzhou.mp4
filelist.txt: file &#39;test1.mp4&#39;
              file &#39;test1.mp4&#39;
	      file &#39;test2.mp4&#39;
	      file &#39;test2.mp4&#39;
通过上面的命令我们就可以通过本地的test1.mp4和test2.mp4这两个小视频文件生成一个大视频文件。
Tips: 如果是相对路径，则不需要上面的-safe 0。
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Concat protocol: 该方式是基于文件来操作的，某些文件（例如MPEG-2 transport streams），这类似于在linux系统上使用cat命令或在Windows上进行复制操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;ffmpeg -i &amp;ldquo;concat:test1.mp4|test2.mp4|test3.mp4&amp;rdquo; -c copy yeqiongzhou.mp4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;Concat filter: 这种方式实际上是把所有的视频音频全部解码，统一为原始的音视频流，然后塞进编码器重新编码。这种方式需要视频之间的分辨率和帧率必须一致，优点是兼容性好，能够应付绝大部分场景。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ffmpeg -i test1.mp4 -i test2.webm -i test3.mov \
-filter_complex &amp;quot;[0✌️0][0🅰️0][1✌️0][1🅰️0][2✌️0][2🅰️0]concat=n=3:v=1:a=1[outv][outa]&amp;quot; \
-map &amp;quot;[outv]&amp;quot; -map &amp;quot;[outa]&amp;quot; yeqiongzhou.mkv
通过上面的命令我们合并了三个具有视频流和音频流的文件。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Linux chmod命令</title>
      <link>https://yeqiongzhou.com/2020/05/chmod/</link>
      <pubDate>Tue, 26 May 2020 23:35:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/05/chmod/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;命令详解&#34;&gt;命令详解&lt;/h2&gt;

&lt;p&gt;Linux/Unix 的文件调用权限分为三级: 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。
&lt;strong&gt;使用权限&lt;/strong&gt;: 所有使用者&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;chmod = change mode&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;chmod [-cfvR] [&amp;ndash;help] [&amp;ndash;version] mode file&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;p&gt;mode: 权限设定字串，格式如下 :
&amp;gt; [ugoa&amp;hellip;][[+-=][rwxX]&amp;hellip;][,&amp;hellip;]&lt;/p&gt;

&lt;p&gt;其中:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;u表示该文件的拥有者，g表示与该文件的拥有者属于同一个群体(group)者，o表示其他以外的人，a表示这三者皆是。&lt;/li&gt;
&lt;li&gt;+表示增加权限、-表示取消权限、=表示唯一设定权限。&lt;/li&gt;
&lt;li&gt;r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他参数说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-c: 若该文件权限确实已经更改，才显示其更改动作&lt;/li&gt;
&lt;li&gt;-f: 若该文件权限无法被更改也不要显示错误讯息&lt;/li&gt;
&lt;li&gt;-v: 显示权限变更的详细资料&lt;/li&gt;
&lt;li&gt;-R: 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)&lt;/li&gt;
&lt;li&gt;&amp;ndash;help: 显示辅助说明&lt;/li&gt;
&lt;li&gt;&amp;ndash;version: 显示版本&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;p&gt;1 将文件 yeqiongzhou.txt 设为所有人皆可读取:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chmod ugo+r yeqiongzhou.txt
chmod a+r yeqiongzhou.txt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2 将文件 yeqiongzhou.txt 与 xiaofang.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chmod ug+w,o-w yeqiongzhou.txt xiaofang.txt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3 将 yeqiongzhou.go 设定为只有该文件拥有者可以执行:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chmod u+x yeqiongzhou.go&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4 将目前目录下的所有文件与子目录皆设为任何人可读取:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chmod -R a+r *&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;5 此外chmod也可以用数字来表示权限如:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chmod 777 file
语法为: chmod abc file
其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;r=4，w=2，x=1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若要rwx属性则4+2+1=7；&lt;/li&gt;
&lt;li&gt;若要rw-属性则4+2=6；&lt;/li&gt;
&lt;li&gt;若要r-x属性则4+1=5。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;chmod a=rwx file&lt;/code&gt; 和 &lt;code&gt;chmod 777 file&lt;/code&gt; 效果相同
&lt;code&gt;chmod ug=rwx,o=x file&lt;/code&gt; 和 &lt;code&gt;chmod 771 file&lt;/code&gt; 效果相同&lt;/p&gt;

&lt;h4 id=&#34;注&#34;&gt;注&lt;/h4&gt;

&lt;p&gt;若用chmod 4755 filename可使此程序具有root的权限&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无重复字符的最长子串</title>
      <link>https://yeqiongzhou.com/2020/05/longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 25 May 2020 23:21:21 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/05/longest-substring-without-repeating-characters/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;

&lt;h3 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;输入: &amp;quot;abcabcbb&amp;quot;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;输入: &amp;quot;bbbbb&amp;quot;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;示例-3&#34;&gt;示例 3:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;输入: &amp;quot;pwwkew&amp;quot;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;题解&#34;&gt;题解&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	str := []string{&amp;quot;abcabcbb&amp;quot;, &amp;quot;bbbbb&amp;quot;, &amp;quot;pwwkew&amp;quot;}
	for _, s := range str {
		len := lengthOfLongestSubstring(s)
		fmt.Println(len)
	}
}

func lengthOfLongestSubstring(s string) int {
	lastOccurred := make(map[byte]int)
	start := 0
	maxLength := 0
	for i, ch := range []byte(s) {
		if lastI, ok := lastOccurred[ch]; ok &amp;amp;&amp;amp; lastI &amp;gt;= start {
			start = lastI + 1
		}
		if i-start+1 &amp;gt; maxLength {
			maxLength = i - start + 1
		}
		lastOccurred[ch] = i
	}
	return maxLength
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Linux chgrp命令</title>
      <link>https://yeqiongzhou.com/2020/05/chgrp/</link>
      <pubDate>Mon, 25 May 2020 22:25:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2020/05/chgrp/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;命令详解&#34;&gt;命令详解&lt;/h2&gt;

&lt;p&gt;Linux chgrp命令用于变更文件或目录的所属群组。
在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;chgrp = change group&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;chgrp [-cfhRv][&amp;ndash;help][&amp;ndash;version][所属群组][文件或目录&amp;hellip;]
chgrp [-cfhRv][&amp;ndash;help][&amp;ndash;reference=&amp;lt;参考文件或目录&amp;gt;][&amp;ndash;version][文件或目录&amp;hellip;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;-c或&amp;ndash;changes 效果类似&amp;rdquo;-v&amp;rdquo;参数，但仅回报更改的部分。&lt;/li&gt;
&lt;li&gt;-f或&amp;ndash;quiet或&amp;ndash;silent 不显示错误信息。&lt;/li&gt;
&lt;li&gt;-h或&amp;ndash;no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。&lt;/li&gt;
&lt;li&gt;-R或&amp;ndash;recursive 递归处理，将指定目录下的所有文件及子目录一并处理。&lt;/li&gt;
&lt;li&gt;-v或&amp;ndash;verbose 显示指令执行过程。&lt;/li&gt;
&lt;li&gt;&amp;ndash;help 在线帮助。&lt;/li&gt;
&lt;li&gt;&amp;ndash;reference=&amp;lt;参考文件或目录&amp;gt;，把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。&lt;/li&gt;
&lt;li&gt;&amp;ndash;version 显示版本信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;改变文件的群组属性:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;chgrp -v bin yeqiongzhou.log&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bodhiye@yeqiongzhou ~/Desktop ll
-rw-r--r-- 1 bodhiye staff 0 May 25 22:05 yeqiongzhou.log
bodhiye@yeqiongzhou ~/Desktop chgrp -v bin yeqiongzhou.log
bodhiye@yeqiongzhou ~/Desktop ll
-rw-r--r-- 1 bodhiye bin 0 May 25 22:05 yeqiongzhou.log
可以看到将yeqiongzhou.log文件由staff群组改为了bin群组。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;根据指定文件改变文件的群组属性:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;chgrp &amp;ndash;reference=yeqiongzhou.log xiaofang.log&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bodhiye@yeqiongzhou ~/Desktop ll
-rw-r--r-- 1 bodhiye staff 0 May 25 22:22 xiaofang.log
-rw-r--r-- 1 bodhiye bin   0 May 25 22:05 yeqiongzhou.log
bodhiye@yeqiongzhou ~/Desktop chgrp --reference=yeqiongzhou.log xiaofang.log
bodhiye@yeqiongzhou ~/Desktop ll
-rw-r--r-- 1 bodhiye bin 0 May 25 22:22 xiaofang.log
-rw-r--r-- 1 bodhiye bin 0 May 25 22:05 yeqiongzhou.log
改变文件xiaofang.log 的群组属性，使得文件xiaofang.log的群组属性和参考文件yeqiongzhou.log的群组属性相同。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>