<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>叶琼州的代码小窝 on 叶琼州的代码小窝</title>
    <link>https://yeqiongzhou.com/</link>
    <description>Recent content in 叶琼州的代码小窝 on 叶琼州的代码小窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 18 Dec 2019 08:40:47 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux chattr命令</title>
      <link>https://yeqiongzhou.com/2019/12/chattr/</link>
      <pubDate>Wed, 18 Dec 2019 08:40:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/12/chattr/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;命令详解&#34;&gt;命令详解&lt;/h2&gt;

&lt;p&gt;chattr 命令用于改变文件属性。
这项指令可改变存放在 ext2 文件系统上的文件或目录属性，这些属性共有以下几种模式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a：append only，让文件或目录仅供附加用途，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件安全。&lt;/li&gt;
&lt;li&gt;A：no atime updates，不更新文件或目录的最后存取时间，文件或目录的 atime (access time)不可被修改(modified)。&lt;/li&gt;
&lt;li&gt;c：compressed，将文件或目录压缩后存放，设定文件是否经压缩后再存储，读取时需要经过自动解压操作将文件或目录压缩后存放。&lt;/li&gt;
&lt;li&gt;C：no copy-on-write (COW)，不执行写入时复制，多个调用者获取同一个资源，这时另一个调用者对这资源进行了修改，不生成一个副本。&lt;/li&gt;
&lt;li&gt;d：no dump，将文件或目录排除在倾倒操作之外，设定文件不能成为 dump 程序的备份目标。&lt;/li&gt;
&lt;li&gt;D：synchronous directory updates，同步更新目录。&lt;/li&gt;
&lt;li&gt;e：extent format，extent 格式。&lt;/li&gt;
&lt;li&gt;i：immutable，不得任意更动文件或目录，设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。&lt;/li&gt;
&lt;li&gt;j：data journaling，数据日志，文件在写入时会先被记录。&lt;/li&gt;
&lt;li&gt;s：secure deletion，保密性删除文件或目录，即硬盘空间被全部收回。&lt;/li&gt;
&lt;li&gt;S：synchronous updates，即时更新文件或目录，功能类似 sync。&lt;/li&gt;
&lt;li&gt;t：no tail-merging，文件系统支持尾部合并。&lt;/li&gt;
&lt;li&gt;T：top of directory hierarchy，具有该属性的目录将被视为目录层次结构的顶部。&lt;/li&gt;
&lt;li&gt;u：undeletable，预防意外删除，与s相反，当设定为u时，数据内容其实还存在磁盘中&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;chattr = change attributes&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;chattr [-RVf] [-+=aAcCdDeijsStTu] [-v version] files&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;-R 递归处理，将指定目录下的所有文件及子目录一并处理。&lt;/li&gt;
&lt;li&gt;-v&amp;lt;版本编号&amp;gt; 设置文件或目录版本。&lt;/li&gt;
&lt;li&gt;-V 显示指令执行过程。&lt;/li&gt;
&lt;li&gt;+&amp;lt;属性&amp;gt; 开启文件或目录的该项属性。&lt;/li&gt;
&lt;li&gt;-&amp;lt;属性&amp;gt; 关闭文件或目录的该项属性。&lt;/li&gt;
&lt;li&gt;=&amp;lt;属性&amp;gt; 指定文件或目录的该项属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用 chattr 命令防止系统中某个关键文件被修改:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;chattr +i /root/yeqiongzhou.yaml
lsattr /root/yeqiongzhou.yaml&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;会显示如下属性: &lt;code&gt;----i-------- /root/yeqiongzhou.yaml&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;chattr +a /var/log/messages&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;注&#34;&gt;注&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;各参数选项中常用到的是a和i。a选项强制只可添加不可删除，多用于日志系统的安全设定。而i是更为严格的安全设定，只有superuser (root) 或具有 CAP_LINUX_IMMUTABLE 处理能力（标识）的进程能够施加该选项。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Linux cat命令</title>
      <link>https://yeqiongzhou.com/2019/12/cat/</link>
      <pubDate>Sun, 15 Dec 2019 23:45:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/12/cat/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;命令详解&#34;&gt;命令详解&lt;/h2&gt;

&lt;p&gt;cat 命令用于连接文件并打印到标准输出设备上。&lt;/p&gt;

&lt;h3 id=&#34;命令全拼&#34;&gt;命令全拼&lt;/h3&gt;

&lt;p&gt;cat = concatenate&lt;/p&gt;

&lt;h3 id=&#34;语法格式&#34;&gt;语法格式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;cat [-AbeEnstTv] [&amp;ndash;help] [&amp;ndash;version] fileName&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;-n 或 &amp;ndash;number: 由1开始对所有输出的行数编号。&lt;/li&gt;
&lt;li&gt;-b 或 &amp;ndash;number-nonblank: 和 -n 相似，只不过对于空-不编号。&lt;/li&gt;
&lt;li&gt;-s 或 &amp;ndash;squeeze-blank: 当遇到有连续两行以上的空白行-代换为一行的空白行。&lt;/li&gt;
&lt;li&gt;-v 或 &amp;ndash;show-nonprinting: 使用 ^ 和 M- 符号，除了 -D 和 TAB 之外。&lt;/li&gt;
&lt;li&gt;-E 或 &amp;ndash;show-ends: 在每行结束处显示 $。&lt;/li&gt;
&lt;li&gt;-T 或 &amp;ndash;show-tabs: 将 TAB 字符显示为 ^I。&lt;/li&gt;
&lt;li&gt;-A 或 &amp;ndash;show-all: 等价于 -vET。&lt;/li&gt;
&lt;li&gt;-e: 等价于&amp;rdquo;-vE&amp;rdquo;选项。&lt;/li&gt;
&lt;li&gt;-t: 等价于&amp;rdquo;-vT&amp;rdquo;选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;cat -n textfile1 &amp;gt; textfile2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;cat -b textfile1 textfile2 &amp;gt;&amp;gt; textfile3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;清空 /etc/test.txt 文档内容:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;cat /dev/null &amp;gt; /etc/test.txt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;cat /dev/fd0 &amp;gt; OUTFILE&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;相反的，如果想把 image file 写到软盘，输入:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;cat IMG_FILE &amp;gt; /dev/fd0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;注&#34;&gt;注&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;在类 Unix 系统中，/dev/null 称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据，读取它则会立即得到一个 EOF。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes存活探针</title>
      <link>https://yeqiongzhou.com/2019/04/kubernetes-liveness-probes/</link>
      <pubDate>Fri, 19 Apr 2019 09:31:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/04/kubernetes-liveness-probes/</guid>
      <description>&lt;p&gt;　　Kubernetes可以通过存活探针（liveness probes）检查容器是否还在运行。可以为pod中的每个容器单独指定存活探针。如果探测失败，Kubernetes将定期执行探针并重新启动容器。&lt;/p&gt;

&lt;p&gt;　　Kubernetes有以下三种探测容器的机制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP GET探针对容器的IP地址（你指定的端口和路径）执行HTTP GET请求。如果探测器收到响应，并且响应状态码不代表错误（换句话说，如果HTTP响应状态码是2xx或3xx），则认为探测成功。如果服务器返回错误响应状态码或者根本没有响应，那么探测就被认为是失败的，容器将被重新启动。&lt;/li&gt;
&lt;li&gt;TCP套接字探针尝试与容器指定端口建立TCP连接。如果连接成功建立，则探测成功。否则，容器重新启动。&lt;/li&gt;
&lt;li&gt;Exec探针在容器内执行任意命令，并检查命令的退出状态码。如果状态码是0，则探测成功。所有其他状态码都被认为失败。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>🌸又是一年赏樱时🌸</title>
      <link>https://yeqiongzhou.com/2019/03/sakura/</link>
      <pubDate>Sat, 23 Mar 2019 16:53:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/sakura/</guid>
      <description>

&lt;p&gt;正当武大樱花盛开之际，觉得有必要写一篇文章来记录在武大最后一个年头的樱花节了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;武大樱花背景&#34;&gt;武大樱花背景&lt;/h3&gt;

&lt;p&gt;武大校内樱花约1000多株，以日本樱花、山樱花、垂枝大叶早樱和红花高盆樱4种为主。这些花既有侵华日军当年所留下的“国耻之花”，也有中日恢复邦交后由日本友人多次赠送的“友谊之花”。&lt;/p&gt;

&lt;p&gt;武汉大学的樱花已经有着很长的历史，更有着复杂的历史背景，关于武大樱花多数人并不很清楚，只是停留在日本军人栽种的那种认识状态上。因此美丽的樱花虽然渲染春色，给了人们美的享受，但也带了一些“烦恼”。有人认为樱花是国耻的象征，有人说不要把樱花复杂化；有人说武大因樱花而美丽；也有人说樱花因武大才迷人。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bodhiye/BlogImage/master/album/sakura/yinghua4.jpg&#34; alt=&#34;樱花城堡&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;武大樱花发展历史&#34;&gt;武大樱花发展历史&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1939年日军当年在武汉大学种下的小日樱花不超过30株，主要分布在今天的樱花大道上，至今那些日军栽种的樱花树都早已老死。抗战胜利后，武大于1946年10月复归珞珈山；&lt;/li&gt;
&lt;li&gt;1947年3月，武大生物系师生观察发现，校园里共有28株樱花树开花，它们均匀地分布在老斋舍三个拱门之间及其两侧的四个门栋前（每个门栋前各有7株）。&lt;/li&gt;
&lt;li&gt;1957年，武汉大学对这些樱树进行了更新。&lt;/li&gt;
&lt;li&gt;1973年，武大农场又从上海引进了一批山樱花，同时再次更新了已老化的樱树。由于樱花树的生命周期很短，一般只有二三十年，1939年由日本人种下的第一批日本樱花，50年代更新时已基本死绝。因此，我们今天在武大所看到的日本樱花，已远非当年日军所留下的花种了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bodhiye/BlogImage/master/album/sakura/yinghua1.jpg&#34; alt=&#34;武大樱花&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;武大樱花季&#34;&gt;武大樱花季&lt;/h3&gt;

&lt;p&gt;武大樱花就像我国的著名景区一样，早已负盛名。无论海内外只要到了三四月份，就前赴后继的奔赴武大观赏樱花，无论是感受学子间传播的才气氛围，还是樱花满地所带来的美伦意境，都足以让人觉得不虚此行。但这只是臆想罢了，作为校园而并非正规景点，他是有规定的，每天只限定在某一时间段开放，而且限名额为两万人，去那里可能看不到花，却一定看得到人头涌动，热闹无比的人群。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bodhiye/BlogImage/master/album/sakura/yinghua2.jpg&#34; alt=&#34;樱花大道人潮&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;武大樱花赏析&#34;&gt;武大樱花赏析&lt;/h3&gt;

&lt;p&gt;到武大去看樱花，看那些摇曳的花枝，看那些如花的笑靥，看那些流光溢彩，也看那些深情的凝望。我看到那些年轻的充满深情的眸子，也看到写着岁月沧桑的双眼，此刻春风扑在他们的脸上，我仿佛看到圣洁的诺言美丽如初，我仿佛看到深情中的淡定、从容正在绽放。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bodhiye/BlogImage/master/album/sakura/yinghua3.jpg&#34; alt=&#34;武大行政楼&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>山茶花</title>
      <link>https://yeqiongzhou.com/2019/03/camellia/</link>
      <pubDate>Wed, 13 Mar 2019 14:07:51 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/camellia/</guid>
      <description>

&lt;p&gt;前不久听同学告诉我梅园操场门口的山茶花开了，很久以前就听说过山茶花，不过一直没有见过，索性就趁着这个机会近距离欣赏一下山茶花吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bodhiye/BlogImage/master/album/camellia/shancha1.jpg&#34; alt=&#34;红色山茶花&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;山茶花是我国著名的花卉之一，由于它的株形十分优美典雅，花色丰富多样化，一直都深受很多文人墨客的青睐，而且山茶花寓意着谦逊，理想的爱，美德，可爱，即使在寒冷季节也依旧不失它的高洁美丽。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bodhiye/BlogImage/master/album/camellia/shancha2.jpg&#34; alt=&#34;白色山茶花&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;山茶花花语&#34;&gt;山茶花花语&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;谦让细心呵护&lt;/strong&gt;
因为山茶花的花瓣掉落是一片一片叶子慢慢掉落，带有依依不舍之意，所以山茶花的花语代表了一种谦让和高洁的寓意，比如山茶花送给女孩表现了男孩对女孩爱意的小心翼翼和爱慕之情。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;高洁孤傲&lt;/strong&gt;
因为山茶花是冬末春初盛开的鲜花，就如同梅花一样，带有一种高洁孤傲之意，不愿和众花一起盛开争艳，只愿独自绽放需求一份属于自己的高洁和孤傲，这就是山茶花的另外一层花语寓意。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;深沉谨慎&lt;/strong&gt;
同样因为山茶花的花朵绽放时间，山茶花不愿意和众花一起绽放在夏季，不愿意争芳斗艳，也说明了山茶花有自己的谨慎和深沉，也正是因为这份谨慎和深沉才造就了只属于山茶花的高洁与孤傲。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bodhiye/BlogImage/master/album/camellia/shancha3.jpg&#34; alt=&#34;粉色山茶花&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后来欣赏一下陆游描写山茶花的诗句吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;         《山茶》
         宋 陆游
东园三月雨兼风，桃李飘零扫地空。
唯有山茶偏耐久，绿丛又放数枝红。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bodhiye/BlogImage/master/album/camellia/shancha4.jpg&#34; alt=&#34;山茶花&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>机器人的运动范围</title>
      <link>https://yeqiongzhou.com/2019/03/offer66/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:25 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer66/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int getSum(int n) {
    int sum = 0;
    while (n) {
        sum += n % 10;
        n /= 10;
    }
    return sum;
}

int moving(int threshold, int i, int j, int rows, int cols, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;flag) {
    if (i &amp;lt; 0 || i &amp;gt;= rows || j &amp;lt; 0 || j &amp;gt;= cols || flag[i][j] == 1 || getSum(i) + getSum(j) &amp;gt; threshold)
        return 0;
    flag[i][j] = 1;
    return moving(threshold, i - 1, j, rows, cols, flag) + moving(threshold, i + 1, j, rows, cols, flag) +
           moving(threshold, i, j - 1, rows, cols, flag) + moving(threshold, i, j + 1, rows, cols, flag) + 1;
}

int movingCount(int threshold, int rows, int cols) {
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; flag(rows);
    for (int i = 0; i &amp;lt; rows; i++)
        flag[i].resize(cols, 0);
    return moving(threshold, 0, 0, rows, cols, flag);
}

int main() {
    ios::sync_with_stdio(false);
    int m, n, k;
    cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    cout &amp;lt;&amp;lt; movingCount(k, m, n);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>矩阵中的路径</title>
      <link>https://yeqiongzhou.com/2019/03/offer65/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:21 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer65/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串&amp;rdquo;bcced&amp;rdquo;的路径，但是矩阵中不包含&amp;rdquo;abcb&amp;rdquo;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

bool path(char *matrix, int rows, int cols, int i, int j, char *str, int k, vector&amp;lt;bool&amp;gt; flag) {
    int index = i * cols + j;
    if (i &amp;lt; 0 || i &amp;gt;= rows || j &amp;lt; 0 || j &amp;gt;= cols || matrix[index] != str[k] || flag[index])
        return false;
    if (k == strlen(str) - 1)
        return true;
    flag[index] = true;
    if (path(matrix, rows, cols, i - 1, j, str, k + 1, flag) || path(matrix, rows, cols, i + 1, j, str, k + 1, flag) ||
        path(matrix, rows, cols, i, j - 1, str, k + 1, flag) || path(matrix, rows, cols, i, j + 1, str, k + 1, flag))
        return true;
    flag[index] = false;
    return false;
}

bool hasPath(char *matrix, int rows, int cols, char *str) {
    vector&amp;lt;bool&amp;gt; flag(rows * cols, false);
    for (int i = 0; i &amp;lt; rows; i++)
        for (int j = 0; j &amp;lt; cols; j++)
            if (path(matrix, rows, cols, i, j, str, 0, flag))
                return true;
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    int rows, cols;
    char s[101], str[101];
    cin &amp;gt;&amp;gt; rows &amp;gt;&amp;gt; cols &amp;gt;&amp;gt; s &amp;gt;&amp;gt; str;
    cout &amp;lt;&amp;lt; hasPath(s, rows, cols, str);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>滑动窗口的最大值</title>
      <link>https://yeqiongzhou.com/2019/03/offer64/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:18 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer64/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;deque&amp;gt;

using namespace std;

vector&amp;lt;int&amp;gt; maxInWindows(const vector&amp;lt;int&amp;gt; &amp;amp;num, unsigned int size) {
    vector&amp;lt;int&amp;gt; v;
    deque&amp;lt;int&amp;gt; d;
    for (unsigned int i = 0; i &amp;lt; num.size(); ++i) {
        while (d.size() &amp;amp;&amp;amp; num[d.back()] &amp;lt;= num[i])
            d.pop_back();
        if (d.size() &amp;amp;&amp;amp; i - d.front() + 1 &amp;gt; size)
            d.pop_front();
        d.push_back(i);
        if (size &amp;amp;&amp;amp; i + 1 &amp;gt;= size)
            v.push_back(num[d.front()]);
    }
    return v;
}

int main() {
    ios::sync_with_stdio(false);
    vector&amp;lt;int&amp;gt; v, res;
    int n, k, tmp;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; tmp;
        v.push_back(tmp);
    }
    res = maxInWindows(v, k);
    for (auto it = res.begin(); it != res.end(); ++it)
        cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>数据流中的中位数</title>
      <link>https://yeqiongzhou.com/2019/03/offer63/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:13 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer63/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

vector&amp;lt;int&amp;gt; v;
int n;

void Insert(int num) {
    v.push_back(num);
    n = v.size();
    for (int i = n - 1; i &amp;gt; 0 &amp;amp;&amp;amp; v[i] &amp;lt; v[i - 1]; --i)
        swap(v[i], v[i - 1]);
}

double GetMedian() {
    return (v[(n - 1) &amp;gt;&amp;gt; 1] + v[n &amp;gt;&amp;gt; 1]) / 2.0;
}

int main() {
    ios::sync_with_stdio(false);
    int m, tmp;
    cin &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; m; i++) {
        cin &amp;gt;&amp;gt; tmp;
        Insert(tmp);
    }
    cout &amp;lt;&amp;lt; GetMedian();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>二叉搜索树的第k个结点</title>
      <link>https://yeqiongzhou.com/2019/03/offer62/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:07 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer62/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

int count = 0;

TreeNode *KthNode(TreeNode *pRoot, int k) {
    if (pRoot) {
        TreeNode *node = KthNode(pRoot-&amp;gt;left, k);
        if (node) return node;
        if (++count == k)return pRoot;
        node = KthNode(pRoot-&amp;gt;right, k);
        if (node)return node;
    }
    return NULL;
}

int main() {
    ios::sync_with_stdio(false);
    int k;
    cin &amp;gt;&amp;gt; k;
    TreeNode *root = NULL;
    root = newTree();
    cout &amp;lt;&amp;lt; KthNode(root, k)-&amp;gt;val;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>序列化二叉树</title>
      <link>https://yeqiongzhou.com/2019/03/offer61/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:03 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer61/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请实现两个函数，分别用来序列化和反序列化二叉树&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

void preOrder(TreeNode *pRoot)
{
    if (pRoot)
    {
        cout &amp;lt;&amp;lt; pRoot-&amp;gt;val &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        preOrder(pRoot-&amp;gt;left);
        preOrder(pRoot-&amp;gt;right);
    }
}

char* Serialize(TreeNode *root) {
    if(!root)return &amp;quot;#&amp;quot;;
    string s=to_string(root-&amp;gt;val);
    s.push_back(&#39;,&#39;);
    char *left = Serialize(root-&amp;gt;left);
    char *right = Serialize(root-&amp;gt;right);
    char *res = new char[strlen(left) + strlen(right) + s.size()];
    strcpy(res, s.c_str());
    strcat(res, left);
    strcat(res, right);
    return res;
}

TreeNode* decode(char *&amp;amp;str) {
    if(*str==&#39;#&#39;){
        str++;
        return NULL;
    }
    int num = 0;
    while(*str != &#39;,&#39;)
        num = num*10 + (*(str++)-&#39;0&#39;);
    str++;
    TreeNode *root = new TreeNode(num);
    root-&amp;gt;left = decode(str);
    root-&amp;gt;right = decode(str);
    return root;
}

TreeNode* Deserialize(char *str) {
    return decode(str);
}

int main() {
    ios::sync_with_stdio(false);
    TreeNode *root = NULL;
    root = newTree();
    cout&amp;lt;&amp;lt;Serialize(root)&amp;lt;&amp;lt;endl;
    TreeNode * res = Deserialize(Serialize(root));
    preOrder(res);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>把二叉树打印成多行</title>
      <link>https://yeqiongzhou.com/2019/03/offer60/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer60/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; Print(TreeNode *pRoot) {
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    if (!pRoot)return res;
    queue&amp;lt;TreeNode *&amp;gt; q;
    q.push(pRoot);
    while (!q.empty()) {
        vector&amp;lt;int&amp;gt; v;
        int size=q.size();
        for (int i = 0; i &amp;lt; size; ++i) {
            TreeNode *tmp = q.front();
            q.pop();
            v.push_back(tmp-&amp;gt;val);
            if (tmp-&amp;gt;left)q.push(tmp-&amp;gt;left);
            if (tmp-&amp;gt;right)q.push(tmp-&amp;gt;right);
        }
        res.push_back(v);
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    TreeNode *root = NULL;
    root = newTree();
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    res = Print(root);
    for (auto it = res.begin(); it != res.end(); ++it) {
        for (auto i = (*it).begin(); i != (*it).end(); ++i)
            cout &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        cout &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>按之字形顺序打印二叉树</title>
      <link>https://yeqiongzhou.com/2019/03/offer59/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:54 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer59/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; Print(TreeNode *pRoot) {
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    if (!pRoot)return res;
    queue&amp;lt;TreeNode *&amp;gt; q;
    q.push(pRoot);
    bool even = false;
    while (!q.empty()) {
        vector&amp;lt;int&amp;gt; v;
        int size=q.size();
        for (int i = 0; i &amp;lt; size; ++i) {
            TreeNode *tmp = q.front();
            q.pop();
            v.push_back(tmp-&amp;gt;val);
            if (tmp-&amp;gt;left)q.push(tmp-&amp;gt;left);
            if (tmp-&amp;gt;right)q.push(tmp-&amp;gt;right);
        }
        if (even)
            reverse(v.begin(), v.end());
        even = !even;
        res.push_back(v);
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    TreeNode *root = NULL;
    root = newTree();
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    res = Print(root);
    for (auto it = res.begin(); it != res.end(); ++it) {
        for (auto i = (*it).begin(); i != (*it).end(); ++i)
            cout &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        cout &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>对称的二叉树</title>
      <link>https://yeqiongzhou.com/2019/03/offer58/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:51 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer58/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

bool symmetrical(TreeNode *left, TreeNode *right) {
    if (!left &amp;amp;&amp;amp; !right)
        return true;
    if (left &amp;amp;&amp;amp; right)
        return left-&amp;gt;val == right-&amp;gt;val &amp;amp;&amp;amp; symmetrical(left-&amp;gt;left, right-&amp;gt;right) &amp;amp;&amp;amp;
               symmetrical(left-&amp;gt;right, right-&amp;gt;left);
    return false;
}

bool isSymmetrical(TreeNode *pRoot) {
    if (!pRoot)
        return true;
    return symmetrical(pRoot-&amp;gt;left, pRoot-&amp;gt;right);
}

int main() {
    ios::sync_with_stdio(false);
    TreeNode *root = NULL;
    root = newTree();
    cout &amp;lt;&amp;lt; isSymmetrical(root);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>二叉树的下一个结点</title>
      <link>https://yeqiongzhou.com/2019/03/offer57/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:48 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer57/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next;

    TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}

    TreeLinkNode() {}
};

TreeLinkNode *newTree() {
    TreeLinkNode *node = new TreeLinkNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left-&amp;gt;next = node;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right-&amp;gt;next = node;
        node-&amp;gt;right = newTree();
    }
    return node;
}

TreeLinkNode *GetNext(TreeLinkNode *pNode) {
    if (!pNode)return NULL;
    if (pNode-&amp;gt;right) {
        pNode = pNode-&amp;gt;right;
        while (pNode-&amp;gt;left)pNode = pNode-&amp;gt;left;
        return pNode;
    }
    while (pNode-&amp;gt;next) {
        if (pNode-&amp;gt;next-&amp;gt;left == pNode)
            return pNode-&amp;gt;next;
        pNode = pNode-&amp;gt;next;
    }
    return NULL;
}

int main() {
    ios::sync_with_stdio(false);
    TreeLinkNode *node = newTree();
    TreeLinkNode *pNode;
    TreeLinkNode *res = GetNext(pNode);
    cout &amp;lt;&amp;lt; res-&amp;gt;val;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>