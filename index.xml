<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>叶琼州的代码小窝 on 叶琼州的代码小窝</title>
    <link>https://yeqiongzhou.com/</link>
    <description>Recent content in 叶琼州的代码小窝 on 叶琼州的代码小窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 19 Apr 2019 09:31:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Kubernetes存活探针</title>
      <link>https://yeqiongzhou.com/2019/04/kubernetes-liveness-probes/</link>
      <pubDate>Fri, 19 Apr 2019 09:31:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/04/kubernetes-liveness-probes/</guid>
      <description>&lt;p&gt;　　Kubernetes可以通过存活探针（liveness probes）检查容器是否还在运行。可以为pod中的每个容器单独指定存活探针。如果探测失败，Kubernetes将定期执行探针并重新启动容器。&lt;/p&gt;

&lt;p&gt;　　Kubernetes有以下三种探测容器的机制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP GET探针对容器的IP地址（你指定的端口和路径）执行HTTP GET请求。如果探测器收到响应，并且响应状态码不代表错误（换句话说，如果HTTP响应状态码是2xx或3xx），则认为探测成功。如果服务器返回错误响应状态码或者根本没有响应，那么探测就被认为是失败的，容器将被重新启动。&lt;/li&gt;
&lt;li&gt;TCP套接字探针尝试与容器指定端口建立TCP连接。如果连接成功建立，则探测成功。否则，容器重新启动。&lt;/li&gt;
&lt;li&gt;Exec探针在容器内执行任意命令，并检查命令的退出状态码。如果状态码是0，则探测成功。所有其他状态码都被认为失败。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>🌸又是一年赏樱时🌸</title>
      <link>https://yeqiongzhou.com/2019/03/sakura/</link>
      <pubDate>Sat, 23 Mar 2019 16:53:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/sakura/</guid>
      <description>

&lt;p&gt;正当武大樱花盛开之际，觉得有必要写一篇文章来记录在武大最后一个年头的樱花节了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;武大樱花背景&#34;&gt;武大樱花背景&lt;/h3&gt;

&lt;p&gt;武大校内樱花约1000多株，以日本樱花、山樱花、垂枝大叶早樱和红花高盆樱4种为主。这些花既有侵华日军当年所留下的“国耻之花”，也有中日恢复邦交后由日本友人多次赠送的“友谊之花”。&lt;/p&gt;

&lt;p&gt;武汉大学的樱花已经有着很长的历史，更有着复杂的历史背景，关于武大樱花多数人并不很清楚，只是停留在日本军人栽种的那种认识状态上。因此美丽的樱花虽然渲染春色，给了人们美的享受，但也带了一些“烦恼”。有人认为樱花是国耻的象征，有人说不要把樱花复杂化；有人说武大因樱花而美丽；也有人说樱花因武大才迷人。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn.yeqiongzhou.top/yinghua4.jpg&#34; alt=&#34;樱花城堡&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;武大樱花发展历史&#34;&gt;武大樱花发展历史&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1939年日军当年在武汉大学种下的小日樱花不超过30株，主要分布在今天的樱花大道上，至今那些日军栽种的樱花树都早已老死。抗战胜利后，武大于1946年10月复归珞珈山；&lt;/li&gt;
&lt;li&gt;1947年3月，武大生物系师生观察发现，校园里共有28株樱花树开花，它们均匀地分布在老斋舍三个拱门之间及其两侧的四个门栋前（每个门栋前各有7株）。&lt;/li&gt;
&lt;li&gt;1957年，武汉大学对这些樱树进行了更新。&lt;/li&gt;
&lt;li&gt;1973年，武大农场又从上海引进了一批山樱花，同时再次更新了已老化的樱树。由于樱花树的生命周期很短，一般只有二三十年，1939年由日本人种下的第一批日本樱花，50年代更新时已基本死绝。因此，我们今天在武大所看到的日本樱花，已远非当年日军所留下的花种了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn.yeqiongzhou.top/yinghua1.jpg&#34; alt=&#34;武大樱花&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;武大樱花季&#34;&gt;武大樱花季&lt;/h3&gt;

&lt;p&gt;武大樱花就像我国的著名景区一样，早已负盛名。无论海内外只要到了三四月份，就前赴后继的奔赴武大观赏樱花，无论是感受学子间传播的才气氛围，还是樱花满地所带来的美伦意境，都足以让人觉得不虚此行。但这只是臆想罢了，作为校园而并非正规景点，他是有规定的，每天只限定在某一时间段开放，而且限名额为两万人，去那里可能看不到花，却一定看得到人头涌动，热闹无比的人群。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn.yeqiongzhou.top/yinghua2.jpg&#34; alt=&#34;樱花大道人潮&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;武大樱花赏析&#34;&gt;武大樱花赏析&lt;/h3&gt;

&lt;p&gt;到武大去看樱花，看那些摇曳的花枝，看那些如花的笑靥，看那些流光溢彩，也看那些深情的凝望。我看到那些年轻的充满深情的眸子，也看到写着岁月沧桑的双眼，此刻春风扑在他们的脸上，我仿佛看到圣洁的诺言美丽如初，我仿佛看到深情中的淡定、从容正在绽放。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn.yeqiongzhou.top/yinghua3.jpg&#34; alt=&#34;武大行政楼&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>山茶花</title>
      <link>https://yeqiongzhou.com/2019/03/camellia/</link>
      <pubDate>Wed, 13 Mar 2019 14:07:51 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/camellia/</guid>
      <description>

&lt;p&gt;前不久听同学告诉我梅园操场门口的山茶花开了，很久以前就听说过山茶花，不过一直没有见过，索性就趁着这个机会近距离欣赏一下山茶花吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn.yeqiongzhou.top/shancha1.jpg&#34; alt=&#34;红色山茶花&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;山茶花是我国著名的花卉之一，由于它的株形十分优美典雅，花色丰富多样化，一直都深受很多文人墨客的青睐，而且山茶花寓意着谦逊，理想的爱，美德，可爱，即使在寒冷季节也依旧不失它的高洁美丽。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn.yeqiongzhou.top/shancha2.jpg&#34; alt=&#34;白色山茶花&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;山茶花花语&#34;&gt;山茶花花语&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;谦让细心呵护&lt;/strong&gt;
因为山茶花的花瓣掉落是一片一片叶子慢慢掉落，带有依依不舍之意，所以山茶花的花语代表了一种谦让和高洁的寓意，比如山茶花送给女孩表现了男孩对女孩爱意的小心翼翼和爱慕之情。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;高洁孤傲&lt;/strong&gt;
因为山茶花是冬末春初盛开的鲜花，就如同梅花一样，带有一种高洁孤傲之意，不愿和众花一起盛开争艳，只愿独自绽放需求一份属于自己的高洁和孤傲，这就是山茶花的另外一层花语寓意。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;深沉谨慎&lt;/strong&gt;
同样因为山茶花的花朵绽放时间，山茶花不愿意和众花一起绽放在夏季，不愿意争芳斗艳，也说明了山茶花有自己的谨慎和深沉，也正是因为这份谨慎和深沉才造就了只属于山茶花的高洁与孤傲。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn.yeqiongzhou.top/shancha3.jpg&#34; alt=&#34;粉色山茶花&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后来欣赏一下陆游描写山茶花的诗句吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;         《山茶》
         宋 陆游
东园三月雨兼风，桃李飘零扫地空。
唯有山茶偏耐久，绿丛又放数枝红。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn.yeqiongzhou.top/shancha4.jpg&#34; alt=&#34;山茶花&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>机器人的运动范围</title>
      <link>https://yeqiongzhou.com/2019/03/offer66/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:25 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer66/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int getSum(int n) {
    int sum = 0;
    while (n) {
        sum += n % 10;
        n /= 10;
    }
    return sum;
}

int moving(int threshold, int i, int j, int rows, int cols, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;flag) {
    if (i &amp;lt; 0 || i &amp;gt;= rows || j &amp;lt; 0 || j &amp;gt;= cols || flag[i][j] == 1 || getSum(i) + getSum(j) &amp;gt; threshold)
        return 0;
    flag[i][j] = 1;
    return moving(threshold, i - 1, j, rows, cols, flag) + moving(threshold, i + 1, j, rows, cols, flag) +
           moving(threshold, i, j - 1, rows, cols, flag) + moving(threshold, i, j + 1, rows, cols, flag) + 1;
}

int movingCount(int threshold, int rows, int cols) {
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; flag(rows);
    for (int i = 0; i &amp;lt; rows; i++)
        flag[i].resize(cols, 0);
    return moving(threshold, 0, 0, rows, cols, flag);
}

int main() {
    ios::sync_with_stdio(false);
    int m, n, k;
    cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    cout &amp;lt;&amp;lt; movingCount(k, m, n);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>矩阵中的路径</title>
      <link>https://yeqiongzhou.com/2019/03/offer65/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:21 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer65/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串&amp;rdquo;bcced&amp;rdquo;的路径，但是矩阵中不包含&amp;rdquo;abcb&amp;rdquo;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

bool path(char *matrix, int rows, int cols, int i, int j, char *str, int k, vector&amp;lt;bool&amp;gt; flag) {
    int index = i * cols + j;
    if (i &amp;lt; 0 || i &amp;gt;= rows || j &amp;lt; 0 || j &amp;gt;= cols || matrix[index] != str[k] || flag[index])
        return false;
    if (k == strlen(str) - 1)
        return true;
    flag[index] = true;
    if (path(matrix, rows, cols, i - 1, j, str, k + 1, flag) || path(matrix, rows, cols, i + 1, j, str, k + 1, flag) ||
        path(matrix, rows, cols, i, j - 1, str, k + 1, flag) || path(matrix, rows, cols, i, j + 1, str, k + 1, flag))
        return true;
    flag[index] = false;
    return false;
}

bool hasPath(char *matrix, int rows, int cols, char *str) {
    vector&amp;lt;bool&amp;gt; flag(rows * cols, false);
    for (int i = 0; i &amp;lt; rows; i++)
        for (int j = 0; j &amp;lt; cols; j++)
            if (path(matrix, rows, cols, i, j, str, 0, flag))
                return true;
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    int rows, cols;
    char s[101], str[101];
    cin &amp;gt;&amp;gt; rows &amp;gt;&amp;gt; cols &amp;gt;&amp;gt; s &amp;gt;&amp;gt; str;
    cout &amp;lt;&amp;lt; hasPath(s, rows, cols, str);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>滑动窗口的最大值</title>
      <link>https://yeqiongzhou.com/2019/03/offer64/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:18 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer64/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;deque&amp;gt;

using namespace std;

vector&amp;lt;int&amp;gt; maxInWindows(const vector&amp;lt;int&amp;gt; &amp;amp;num, unsigned int size) {
    vector&amp;lt;int&amp;gt; v;
    deque&amp;lt;int&amp;gt; d;
    for (unsigned int i = 0; i &amp;lt; num.size(); ++i) {
        while (d.size() &amp;amp;&amp;amp; num[d.back()] &amp;lt;= num[i])
            d.pop_back();
        if (d.size() &amp;amp;&amp;amp; i - d.front() + 1 &amp;gt; size)
            d.pop_front();
        d.push_back(i);
        if (size &amp;amp;&amp;amp; i + 1 &amp;gt;= size)
            v.push_back(num[d.front()]);
    }
    return v;
}

int main() {
    ios::sync_with_stdio(false);
    vector&amp;lt;int&amp;gt; v, res;
    int n, k, tmp;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; tmp;
        v.push_back(tmp);
    }
    res = maxInWindows(v, k);
    for (auto it = res.begin(); it != res.end(); ++it)
        cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>数据流中的中位数</title>
      <link>https://yeqiongzhou.com/2019/03/offer63/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:13 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer63/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

vector&amp;lt;int&amp;gt; v;
int n;

void Insert(int num) {
    v.push_back(num);
    n = v.size();
    for (int i = n - 1; i &amp;gt; 0 &amp;amp;&amp;amp; v[i] &amp;lt; v[i - 1]; --i)
        swap(v[i], v[i - 1]);
}

double GetMedian() {
    return (v[(n - 1) &amp;gt;&amp;gt; 1] + v[n &amp;gt;&amp;gt; 1]) / 2.0;
}

int main() {
    ios::sync_with_stdio(false);
    int m, tmp;
    cin &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; m; i++) {
        cin &amp;gt;&amp;gt; tmp;
        Insert(tmp);
    }
    cout &amp;lt;&amp;lt; GetMedian();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>二叉搜索树的第k个结点</title>
      <link>https://yeqiongzhou.com/2019/03/offer62/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:07 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer62/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

int count = 0;

TreeNode *KthNode(TreeNode *pRoot, int k) {
    if (pRoot) {
        TreeNode *node = KthNode(pRoot-&amp;gt;left, k);
        if (node) return node;
        if (++count == k)return pRoot;
        node = KthNode(pRoot-&amp;gt;right, k);
        if (node)return node;
    }
    return NULL;
}

int main() {
    ios::sync_with_stdio(false);
    int k;
    cin &amp;gt;&amp;gt; k;
    TreeNode *root = NULL;
    root = newTree();
    cout &amp;lt;&amp;lt; KthNode(root, k)-&amp;gt;val;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>序列化二叉树</title>
      <link>https://yeqiongzhou.com/2019/03/offer61/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:03 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer61/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请实现两个函数，分别用来序列化和反序列化二叉树&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

void preOrder(TreeNode *pRoot)
{
    if (pRoot)
    {
        cout &amp;lt;&amp;lt; pRoot-&amp;gt;val &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        preOrder(pRoot-&amp;gt;left);
        preOrder(pRoot-&amp;gt;right);
    }
}

char* Serialize(TreeNode *root) {
    if(!root)return &amp;quot;#&amp;quot;;
    string s=to_string(root-&amp;gt;val);
    s.push_back(&#39;,&#39;);
    char *left = Serialize(root-&amp;gt;left);
    char *right = Serialize(root-&amp;gt;right);
    char *res = new char[strlen(left) + strlen(right) + s.size()];
    strcpy(res, s.c_str());
    strcat(res, left);
    strcat(res, right);
    return res;
}

TreeNode* decode(char *&amp;amp;str) {
    if(*str==&#39;#&#39;){
        str++;
        return NULL;
    }
    int num = 0;
    while(*str != &#39;,&#39;)
        num = num*10 + (*(str++)-&#39;0&#39;);
    str++;
    TreeNode *root = new TreeNode(num);
    root-&amp;gt;left = decode(str);
    root-&amp;gt;right = decode(str);
    return root;
}

TreeNode* Deserialize(char *str) {
    return decode(str);
}

int main() {
    ios::sync_with_stdio(false);
    TreeNode *root = NULL;
    root = newTree();
    cout&amp;lt;&amp;lt;Serialize(root)&amp;lt;&amp;lt;endl;
    TreeNode * res = Deserialize(Serialize(root));
    preOrder(res);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>把二叉树打印成多行</title>
      <link>https://yeqiongzhou.com/2019/03/offer60/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer60/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; Print(TreeNode *pRoot) {
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    if (!pRoot)return res;
    queue&amp;lt;TreeNode *&amp;gt; q;
    q.push(pRoot);
    while (!q.empty()) {
        vector&amp;lt;int&amp;gt; v;
        int size=q.size();
        for (int i = 0; i &amp;lt; size; ++i) {
            TreeNode *tmp = q.front();
            q.pop();
            v.push_back(tmp-&amp;gt;val);
            if (tmp-&amp;gt;left)q.push(tmp-&amp;gt;left);
            if (tmp-&amp;gt;right)q.push(tmp-&amp;gt;right);
        }
        res.push_back(v);
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    TreeNode *root = NULL;
    root = newTree();
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    res = Print(root);
    for (auto it = res.begin(); it != res.end(); ++it) {
        for (auto i = (*it).begin(); i != (*it).end(); ++i)
            cout &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        cout &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>按之字形顺序打印二叉树</title>
      <link>https://yeqiongzhou.com/2019/03/offer59/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:54 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer59/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; Print(TreeNode *pRoot) {
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    if (!pRoot)return res;
    queue&amp;lt;TreeNode *&amp;gt; q;
    q.push(pRoot);
    bool even = false;
    while (!q.empty()) {
        vector&amp;lt;int&amp;gt; v;
        int size=q.size();
        for (int i = 0; i &amp;lt; size; ++i) {
            TreeNode *tmp = q.front();
            q.pop();
            v.push_back(tmp-&amp;gt;val);
            if (tmp-&amp;gt;left)q.push(tmp-&amp;gt;left);
            if (tmp-&amp;gt;right)q.push(tmp-&amp;gt;right);
        }
        if (even)
            reverse(v.begin(), v.end());
        even = !even;
        res.push_back(v);
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    TreeNode *root = NULL;
    root = newTree();
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; res;
    res = Print(root);
    for (auto it = res.begin(); it != res.end(); ++it) {
        for (auto i = (*it).begin(); i != (*it).end(); ++i)
            cout &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        cout &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>对称的二叉树</title>
      <link>https://yeqiongzhou.com/2019/03/offer58/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:51 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer58/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;

    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }

    TreeNode() {}
};

TreeNode *newTree() {
    TreeNode *node = new TreeNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right = newTree();
    }
    return node;
}

bool symmetrical(TreeNode *left, TreeNode *right) {
    if (!left &amp;amp;&amp;amp; !right)
        return true;
    if (left &amp;amp;&amp;amp; right)
        return left-&amp;gt;val == right-&amp;gt;val &amp;amp;&amp;amp; symmetrical(left-&amp;gt;left, right-&amp;gt;right) &amp;amp;&amp;amp;
               symmetrical(left-&amp;gt;right, right-&amp;gt;left);
    return false;
}

bool isSymmetrical(TreeNode *pRoot) {
    if (!pRoot)
        return true;
    return symmetrical(pRoot-&amp;gt;left, pRoot-&amp;gt;right);
}

int main() {
    ios::sync_with_stdio(false);
    TreeNode *root = NULL;
    root = newTree();
    cout &amp;lt;&amp;lt; isSymmetrical(root);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>二叉树的下一个结点</title>
      <link>https://yeqiongzhou.com/2019/03/offer57/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:48 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer57/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next;

    TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}

    TreeLinkNode() {}
};

TreeLinkNode *newTree() {
    TreeLinkNode *node = new TreeLinkNode;
    int x;
    cin &amp;gt;&amp;gt; x;
    if (!x)node = NULL;
    else {
        node-&amp;gt;val = x;
        node-&amp;gt;left-&amp;gt;next = node;
        node-&amp;gt;left = newTree();
        node-&amp;gt;right-&amp;gt;next = node;
        node-&amp;gt;right = newTree();
    }
    return node;
}

TreeLinkNode *GetNext(TreeLinkNode *pNode) {
    if (!pNode)return NULL;
    if (pNode-&amp;gt;right) {
        pNode = pNode-&amp;gt;right;
        while (pNode-&amp;gt;left)pNode = pNode-&amp;gt;left;
        return pNode;
    }
    while (pNode-&amp;gt;next) {
        if (pNode-&amp;gt;next-&amp;gt;left == pNode)
            return pNode-&amp;gt;next;
        pNode = pNode-&amp;gt;next;
    }
    return NULL;
}

int main() {
    ios::sync_with_stdio(false);
    TreeLinkNode *node = newTree();
    TreeLinkNode *pNode;
    TreeLinkNode *res = GetNext(pNode);
    cout &amp;lt;&amp;lt; res-&amp;gt;val;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>删除链表中重复的结点</title>
      <link>https://yeqiongzhou.com/2019/03/offer56/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:44 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer56/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 处理后为 1-&amp;gt;2-&amp;gt;5&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;

    ListNode(int x) : val(x), next(NULL) {}

    ListNode() {}
};

ListNode *newList() {
    ListNode *L = new ListNode;
    L-&amp;gt;next = NULL;
    ListNode *q = L;
    int n;
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        ListNode *p = new ListNode;
        cin &amp;gt;&amp;gt; p-&amp;gt;val;
        q-&amp;gt;next = p;
        q = p;
    }
    q-&amp;gt;next = NULL;
    return L-&amp;gt;next;
}

void print(ListNode *pHead) {
    while (pHead) {
        cout &amp;lt;&amp;lt; pHead-&amp;gt;val &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        pHead = pHead-&amp;gt;next;
    }
}

ListNode *deleteDuplication(ListNode *pHead) {
    if (pHead == NULL || pHead-&amp;gt;next == NULL)
        return pHead;
    if (pHead-&amp;gt;val == pHead-&amp;gt;next-&amp;gt;val) {
        ListNode *pNode = pHead-&amp;gt;next;
        while (pNode != NULL &amp;amp;&amp;amp; pNode-&amp;gt;val == pHead-&amp;gt;val) {
            pNode = pNode-&amp;gt;next;
        }
        return deleteDuplication(pNode);
    } else {
        pHead-&amp;gt;next = deleteDuplication(pHead-&amp;gt;next);
        return pHead;
    }
}

int main() {
    ios::sync_with_stdio(false);
    ListNode *L = newList();
    ListNode *res = deleteDuplication(L);
    print(res);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>链表中环的入口结点</title>
      <link>https://yeqiongzhou.com/2019/03/offer55/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:40 +0800</pubDate>
      
      <guid>https://yeqiongzhou.com/2019/03/offer55/</guid>
      <description>

&lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;

&lt;p&gt;给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。&lt;/p&gt;

&lt;h4 id=&#34;题解&#34;&gt;题解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;

    ListNode(int x) : val(x), next(NULL) {}

    ListNode() {}
};

ListNode *newList() {
    ListNode *L = new ListNode;
    L-&amp;gt;next = NULL;
    ListNode *q = L;
    int n;
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        ListNode *p = new ListNode;
        cin &amp;gt;&amp;gt; p-&amp;gt;val;
        q-&amp;gt;next = p;
        q = p;
    }
    q-&amp;gt;next = NULL;
    return L-&amp;gt;next;
}

ListNode *EntryNodeOfLoop(ListNode *pHead) {
    if (pHead == NULL || pHead-&amp;gt;next == NULL)
        return NULL;
    ListNode *p1 = pHead, *p2 = pHead;
    while (p2 != NULL &amp;amp;&amp;amp; p2-&amp;gt;next != NULL) {
        p1 = p1-&amp;gt;next;
        p2 = p2-&amp;gt;next-&amp;gt;next;
        if (p1 == p2) {
            p2 = pHead;
            while (p1 != p2) {
                p1 = p1-&amp;gt;next;
                p2 = p2-&amp;gt;next;
            }
            if (p1 == p2)
                return p1;
        }
    }
    return NULL;
}

int main() {
    ios::sync_with_stdio(false);
    ListNode *L = newList();
    cout &amp;lt;&amp;lt; EntryNodeOfLoop(L)-&amp;gt;val;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>