<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 叶琼州的代码小窝</title>
    <link>https://yeqiongzhou.top/posts/</link>
    <description>Recent content in Posts on 叶琼州的代码小窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 23 Mar 2019 16:53:00 +0800</lastBuildDate>
    
	<atom:link href="https://yeqiongzhou.top/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>🌸又是一年赏樱时🌸</title>
      <link>https://yeqiongzhou.top/2019/03/sakura/</link>
      <pubDate>Sat, 23 Mar 2019 16:53:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/sakura/</guid>
      <description>正当武大樱花盛开之际，觉得有必要写一篇文章来记录在武大最后一个年头的樱花节了。 武大樱花背景 武大校内樱花约1000多株，以日本樱花、山樱花、垂</description>
    </item>
    
    <item>
      <title>山茶花</title>
      <link>https://yeqiongzhou.top/2019/03/camellia/</link>
      <pubDate>Wed, 13 Mar 2019 14:07:51 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/camellia/</guid>
      <description>前不久听同学告诉我梅园操场门口的山茶花开了，很久以前就听说过山茶花，不过一直没有见过，索性就趁着这个机会近距离欣赏一下山茶花吧。 山茶花是我国</description>
    </item>
    
    <item>
      <title>机器人的运动范围</title>
      <link>https://yeqiongzhou.top/2019/03/offer66/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:25 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer66/</guid>
      <description>题目描述 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列</description>
    </item>
    
    <item>
      <title>矩阵中的路径</title>
      <link>https://yeqiongzhou.top/2019/03/offer65/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:21 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer65/</guid>
      <description>题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向</description>
    </item>
    
    <item>
      <title>滑动窗口的最大值</title>
      <link>https://yeqiongzhou.top/2019/03/offer64/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:18 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer64/</guid>
      <description>题目描述 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3</description>
    </item>
    
    <item>
      <title>数据流中的中位数</title>
      <link>https://yeqiongzhou.top/2019/03/offer63/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:13 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer63/</guid>
      <description>题目描述 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数</description>
    </item>
    
    <item>
      <title>二叉搜索树的第k个结点</title>
      <link>https://yeqiongzhou.top/2019/03/offer62/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:07 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer62/</guid>
      <description>题目描述 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 题解 #include &amp;lt;iostream&amp;gt;</description>
    </item>
    
    <item>
      <title>序列化二叉树</title>
      <link>https://yeqiongzhou.top/2019/03/offer61/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:03 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer61/</guid>
      <description>题目描述 请实现两个函数，分别用来序列化和反序列化二叉树 题解 #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } TreeNode() {} }; TreeNode *newTree() { TreeNode *node = new TreeNode; int x; cin &amp;gt;&amp;gt;</description>
    </item>
    
    <item>
      <title>把二叉树打印成多行</title>
      <link>https://yeqiongzhou.top/2019/03/offer60/</link>
      <pubDate>Wed, 06 Mar 2019 19:23:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer60/</guid>
      <description>题目描述 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 题解 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } TreeNode() {}</description>
    </item>
    
    <item>
      <title>按之字形顺序打印二叉树</title>
      <link>https://yeqiongzhou.top/2019/03/offer59/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:54 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer59/</guid>
      <description>题目描述 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他</description>
    </item>
    
    <item>
      <title>对称的二叉树</title>
      <link>https://yeqiongzhou.top/2019/03/offer58/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:51 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer58/</guid>
      <description>题目描述 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct TreeNode { int</description>
    </item>
    
    <item>
      <title>二叉树的下一个结点</title>
      <link>https://yeqiongzhou.top/2019/03/offer57/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:48 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer57/</guid>
      <description>题目描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针</description>
    </item>
    
    <item>
      <title>删除链表中重复的结点</title>
      <link>https://yeqiongzhou.top/2019/03/offer56/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:44 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer56/</guid>
      <description>题目描述 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&amp;gt;2-&amp;gt;3</description>
    </item>
    
    <item>
      <title>链表中环的入口结点</title>
      <link>https://yeqiongzhou.top/2019/03/offer55/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:40 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer55/</guid>
      <description>题目描述 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} ListNode() {} }; ListNode *newList() { ListNode *L =</description>
    </item>
    
    <item>
      <title>字符流中第一个不重复的字符</title>
      <link>https://yeqiongzhou.top/2019/03/offer54/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:36 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer54/</guid>
      <description>题目描述 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&amp;rdquo;go&amp;rdquo;时，第一个只</description>
    </item>
    
    <item>
      <title>表示数值的字符串</title>
      <link>https://yeqiongzhou.top/2019/03/offer53/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:32 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer53/</guid>
      <description>题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&amp;rdquo;+100&amp;rdquo;,&amp;ldquo;5e2&amp;</description>
    </item>
    
    <item>
      <title>正则表达式匹配</title>
      <link>https://yeqiongzhou.top/2019/03/offer52/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:27 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer52/</guid>
      <description>题目描述 请实现一个函数用来匹配包括&amp;rsquo;.&amp;lsquo;和&amp;rsquo;&amp;lsquo;的正则表达式。模式中的字符&amp;rsquo;.&amp;l</description>
    </item>
    
    <item>
      <title>构建乘积数组</title>
      <link>https://yeqiongzhou.top/2019/03/offer51/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:23 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer51/</guid>
      <description>题目描述 给定一个数组A[0,1,&amp;hellip;,n-1],请构建一个数组B[0,1,&amp;hellip;,n-1],其中B中的元素B[i]=A</description>
    </item>
    
    <item>
      <title>数组中重复的数字</title>
      <link>https://yeqiongzhou.top/2019/03/offer50/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:20 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer50/</guid>
      <description>题目描述 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次</description>
    </item>
    
    <item>
      <title>把字符串转换成整数</title>
      <link>https://yeqiongzhou.top/2019/03/offer49/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:15 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer49/</guid>
      <description>题目描述 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求</description>
    </item>
    
    <item>
      <title>不用加减乘除做加法</title>
      <link>https://yeqiongzhou.top/2019/03/offer48/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:11 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer48/</guid>
      <description>题目描述 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; int Add(int num1, int num2) { while (num2) { int carry = num1 ^num2; num2 = (num1 &amp;amp; num2) &amp;lt;&amp;lt;</description>
    </item>
    
    <item>
      <title>求1&#43;2&#43;3&#43;...&#43;n</title>
      <link>https://yeqiongzhou.top/2019/03/offer47/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:07 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer47/</guid>
      <description>题目描述 求1+2+3+&amp;hellip;+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断</description>
    </item>
    
    <item>
      <title>孩子们的游戏(圆圈中最后剩下的数)</title>
      <link>https://yeqiongzhou.top/2019/03/offer46/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:03 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer46/</guid>
      <description>题目描述 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个</description>
    </item>
    
    <item>
      <title>扑克牌顺子</title>
      <link>https://yeqiongzhou.top/2019/03/offer45/</link>
      <pubDate>Wed, 06 Mar 2019 19:22:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer45/</guid>
      <description>题目描述 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)&amp;hellip;他随机从中抽</description>
    </item>
    
    <item>
      <title>翻转单词顺序列</title>
      <link>https://yeqiongzhou.top/2019/03/offer44/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:57 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer44/</guid>
      <description>题目描述 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向F</description>
    </item>
    
    <item>
      <title>左旋转字符串</title>
      <link>https://yeqiongzhou.top/2019/03/offer43/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:52 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer43/</guid>
      <description>题目描述 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请</description>
    </item>
    
    <item>
      <title>和为S的两个数字</title>
      <link>https://yeqiongzhou.top/2019/03/offer42/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:43 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer42/</guid>
      <description>题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出</description>
    </item>
    
    <item>
      <title>和为S的连续正数序列</title>
      <link>https://yeqiongzhou.top/2019/03/offer41/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:39 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer41/</guid>
      <description>题目描述 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少</description>
    </item>
    
    <item>
      <title>数组中只出现一次的数字</title>
      <link>https://yeqiongzhou.top/2019/03/offer40/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:33 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer40/</guid>
      <description>题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 题解 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; void FindNumsAppearOnce(vector&amp;lt;int&amp;gt; data, int* num1, int *num2) { int res</description>
    </item>
    
    <item>
      <title>平衡二叉树</title>
      <link>https://yeqiongzhou.top/2019/03/offer39/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:25 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer39/</guid>
      <description>题目描述 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 题解 #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} TreeNode() {} }; TreeNode* newTree() { TreeNode* node = new TreeNode; int x; cin</description>
    </item>
    
    <item>
      <title>二叉树的深度</title>
      <link>https://yeqiongzhou.top/2019/03/offer38/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:22 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer38/</guid>
      <description>题目描述 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 题解 #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt;</description>
    </item>
    
    <item>
      <title>数字在排序数组中出现的次数</title>
      <link>https://yeqiongzhou.top/2019/03/offer37/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:19 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer37/</guid>
      <description>题目描述 统计一个数字在排序数组中出现的次数。 题解 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; int binarySearch(vector&amp;lt;int&amp;gt; data, int left, int right, int k) { while (left &amp;lt;= right) { int mid = (left + right) &amp;gt;&amp;gt; 1; if (k == data[mid]) return mid; else if (k &amp;lt; data[mid]) right = mid - 1;</description>
    </item>
    
    <item>
      <title>两个链表的第一个公共结点</title>
      <link>https://yeqiongzhou.top/2019/03/offer36/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:15 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer36/</guid>
      <description>题目描述 输入两个链表，找出它们的第一个公共结点。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct ListNode { int val; ListNode* next; ListNode(int x) :val(x), next(NULL) {} ListNode() {} }; ListNode* newList() { ListNode* L = new ListNode; L-&amp;gt;next = NULL; ListNode* q = L; int n; cin &amp;gt;&amp;gt; n; for (int i =</description>
    </item>
    
    <item>
      <title>数组中的逆序对</title>
      <link>https://yeqiongzhou.top/2019/03/offer35/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:13 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer35/</guid>
      <description>题目描述 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P</description>
    </item>
    
    <item>
      <title>第一个只出现一次的字符位置</title>
      <link>https://yeqiongzhou.top/2019/03/offer34/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:10 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer34/</guid>
      <description>题目描述 在一个字符串(0&amp;lt;=字符串长度&amp;lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返</description>
    </item>
    
    <item>
      <title>丑数</title>
      <link>https://yeqiongzhou.top/2019/03/offer33/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:06 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer33/</guid>
      <description>题目描述 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做</description>
    </item>
    
    <item>
      <title>把数组排成最小的数</title>
      <link>https://yeqiongzhou.top/2019/03/offer32/</link>
      <pubDate>Wed, 06 Mar 2019 19:21:03 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer32/</guid>
      <description>题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印</description>
    </item>
    
    <item>
      <title>整数中1出现的次数（从1到n整数中1出现的次数）</title>
      <link>https://yeqiongzhou.top/2019/03/offer31/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:59 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer31/</guid>
      <description>题目描述 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、1</description>
    </item>
    
    <item>
      <title>连续子数组的最大和</title>
      <link>https://yeqiongzhou.top/2019/03/offer30/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:55 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer30/</guid>
      <description>题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的</description>
    </item>
    
    <item>
      <title>最小的K个数</title>
      <link>https://yeqiongzhou.top/2019/03/offer29/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:51 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer29/</guid>
      <description>题目描述 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 题解 #include &amp;lt;iostream&amp;gt; #include</description>
    </item>
    
    <item>
      <title>数组中出现次数超过一半的数字</title>
      <link>https://yeqiongzhou.top/2019/03/offer28/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer28/</guid>
      <description>题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于</description>
    </item>
    
    <item>
      <title>字符串的排列</title>
      <link>https://yeqiongzhou.top/2019/03/offer27/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:44 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer27/</guid>
      <description>题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc</description>
    </item>
    
    <item>
      <title>二叉搜索树与双向链表</title>
      <link>https://yeqiongzhou.top/2019/03/offer26/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:41 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer26/</guid>
      <description>题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct TreeNode</description>
    </item>
    
    <item>
      <title>复杂链表的复制</title>
      <link>https://yeqiongzhou.top/2019/03/offer25/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:38 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer25/</guid>
      <description>题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的</description>
    </item>
    
    <item>
      <title>二叉树中和为某一值的路径</title>
      <link>https://yeqiongzhou.top/2019/03/offer24/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:35 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer24/</guid>
      <description>题目描述 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结</description>
    </item>
    
    <item>
      <title>二叉搜索树的后序遍历序列</title>
      <link>https://yeqiongzhou.top/2019/03/offer23/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:31 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer23/</guid>
      <description>题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不</description>
    </item>
    
    <item>
      <title>从上往下打印二叉树</title>
      <link>https://yeqiongzhou.top/2019/03/offer22/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:28 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer22/</guid>
      <description>题目描述 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 题解 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} TreeNode() {} }; TreeNode* newTree() { TreeNode* node = new TreeNode; int</description>
    </item>
    
    <item>
      <title>栈的压入、弹出序列</title>
      <link>https://yeqiongzhou.top/2019/03/offer21/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:24 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer21/</guid>
      <description>题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2</description>
    </item>
    
    <item>
      <title>包含min函数的栈</title>
      <link>https://yeqiongzhou.top/2019/03/offer20/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:20 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer20/</guid>
      <description>题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 题解 #include &amp;lt;iostream&amp;gt; #include &amp;lt;stack&amp;gt; using namespace std; stack&amp;lt;int&amp;gt; s, smin; void push(int value)</description>
    </item>
    
    <item>
      <title>顺时针打印矩阵</title>
      <link>https://yeqiongzhou.top/2019/03/offer19/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:16 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer19/</guid>
      <description>题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打</description>
    </item>
    
    <item>
      <title>二叉树的镜像</title>
      <link>https://yeqiongzhou.top/2019/03/offer18/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:12 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer18/</guid>
      <description>题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述: 二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ /</description>
    </item>
    
    <item>
      <title>树的子结构</title>
      <link>https://yeqiongzhou.top/2019/03/offer17/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:08 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer17/</guid>
      <description>题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) :</description>
    </item>
    
    <item>
      <title>合并两个排序的链表</title>
      <link>https://yeqiongzhou.top/2019/03/offer16/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:03 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer16/</guid>
      <description>题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode(int x) :val(x), next(NULL) {} ListNode()</description>
    </item>
    
    <item>
      <title>反转链表</title>
      <link>https://yeqiongzhou.top/2019/03/offer15/</link>
      <pubDate>Wed, 06 Mar 2019 19:20:00 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer15/</guid>
      <description>题目描述 输入一个链表，反转链表后，输出新链表的表头。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode(int x) :val(x), next(NULL) {} ListNode() {} }; ListNode *ReverseList(ListNode *pHead) { if (pHead == NULL) return NULL; ListNode *pre = NULL, *next = NULL; while (pHead != NULL) {</description>
    </item>
    
    <item>
      <title>链表中倒数第k个结点</title>
      <link>https://yeqiongzhou.top/2019/03/offer14/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:57 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer14/</guid>
      <description>题目描述 输入一个链表，输出该链表中倒数第k个结点。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode(int x) :val(x), next(NULL) {} ListNode() {} }; ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { ListNode *p, *q; p = q = pListHead; int i = 0; for (; p !=</description>
    </item>
    
    <item>
      <title>调整数组顺序使奇数位于偶数前面</title>
      <link>https://yeqiongzhou.top/2019/03/offer13/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:51 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer13/</guid>
      <description>题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和</description>
    </item>
    
    <item>
      <title>数值的整数次方</title>
      <link>https://yeqiongzhou.top/2019/03/offer12/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:48 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer12/</guid>
      <description>题目描述 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; double power(double base, int</description>
    </item>
    
    <item>
      <title>二进制中1的个数</title>
      <link>https://yeqiongzhou.top/2019/03/offer11/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:42 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer11/</guid>
      <description>题目描述 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; int NumberOf1(int n) { int count = 0; while (n != 0) { count++; n = n &amp;amp; (n - 1); } return count; } int main()</description>
    </item>
    
    <item>
      <title>矩形覆盖</title>
      <link>https://yeqiongzhou.top/2019/03/offer10/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:37 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer10/</guid>
      <description>题目描述 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 题解</description>
    </item>
    
    <item>
      <title>变态跳台阶</title>
      <link>https://yeqiongzhou.top/2019/03/offer09/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:33 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer09/</guid>
      <description>题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 题解 #include &amp;lt;iostream&amp;gt; using namespace std; int jumpFloor(int number) {</description>
    </item>
    
    <item>
      <title>跳台阶</title>
      <link>https://yeqiongzhou.top/2019/03/offer08/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:30 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer08/</guid>
      <description>题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 题解 #include &amp;lt;iostream&amp;gt; using namespace std;</description>
    </item>
    
    <item>
      <title>斐波那契数列</title>
      <link>https://yeqiongzhou.top/2019/03/offer07/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:26 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer07/</guid>
      <description>题目描述 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&amp;lt;=39 题解 #include &amp;lt;iostream&amp;gt; using namespace std; int dp[40]; int Fibonacci(int n) { if</description>
    </item>
    
    <item>
      <title>旋转数组的最小数字</title>
      <link>https://yeqiongzhou.top/2019/03/offer06/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:22 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer06/</guid>
      <description>题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组</description>
    </item>
    
    <item>
      <title>用两个栈实现队列</title>
      <link>https://yeqiongzhou.top/2019/03/offer05/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:18 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer05/</guid>
      <description>题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 题解 #include &amp;lt;iostream&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; using namespace std; stack&amp;lt;int&amp;gt; stack1, stack2; queue&amp;lt;int&amp;gt; queue1, queue2; void push1(int node) { stack1.push(node); } int pop1()</description>
    </item>
    
    <item>
      <title>重建二叉树</title>
      <link>https://yeqiongzhou.top/2019/03/offer04/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:14 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer04/</guid>
      <description>题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列</description>
    </item>
    
    <item>
      <title>从尾到头打印链表</title>
      <link>https://yeqiongzhou.top/2019/03/offer03/</link>
      <pubDate>Wed, 06 Mar 2019 19:19:09 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer03/</guid>
      <description>题目描述 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 题解 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;stack&amp;gt; using namespace std; vector&amp;lt;int&amp;gt; dev; stack&amp;lt;int&amp;gt; s; struct ListNode { int val; ListNode* next; ListNode(int x) :val(x), next(NULL) {} ListNode() {} }; vector&amp;lt;int&amp;gt; printListFromTailToHead(ListNode* head) {</description>
    </item>
    
    <item>
      <title>替换空格</title>
      <link>https://yeqiongzhou.top/2019/03/offer02/</link>
      <pubDate>Wed, 06 Mar 2019 19:15:53 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer02/</guid>
      <description>题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are</description>
    </item>
    
    <item>
      <title>二维数组中的查找</title>
      <link>https://yeqiongzhou.top/2019/03/offer01/</link>
      <pubDate>Wed, 06 Mar 2019 19:10:30 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/offer01/</guid>
      <description>题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，</description>
    </item>
    
    <item>
      <title>宝剑藏千年,谁人能识君?</title>
      <link>https://yeqiongzhou.top/2019/03/hubei-provincial-museum/</link>
      <pubDate>Mon, 04 Mar 2019 09:15:56 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/hubei-provincial-museum/</guid>
      <description>湖北省博物馆 趁着周末去了湖北省博物馆（以下简称省博），亲眼见到了《国家宝藏》中出现的越王勾践剑和曾侯乙编钟，这两件文物堪称省博的镇馆之宝。 宝</description>
    </item>
    
    <item>
      <title>Markdown语法手册</title>
      <link>https://yeqiongzhou.top/2019/03/markdown/</link>
      <pubDate>Fri, 01 Mar 2019 19:36:47 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/03/markdown/</guid>
      <description>Markdown 简明语法手册 1. 斜体和粗体 使用 * _ 和 ** _ _ 表示斜体和粗体。 示例： 这是 斜体 ，这是 粗体 。 2. 分级标题 使用任意个 = 表示一级标题，使用 - 表示二级标题，</description>
    </item>
    
    <item>
      <title>交换两个变量的值</title>
      <link>https://yeqiongzhou.top/2019/02/exchange-two-variables/</link>
      <pubDate>Thu, 28 Feb 2019 20:31:35 +0800</pubDate>
      
      <guid>https://yeqiongzhou.top/2019/02/exchange-two-variables/</guid>
      <description>1、借助第三个变量来实现 C = A; A = B; B = C; 2、利用加减法来实现两个变量的交换 A = A + B; B = A – B; A = A – B; 3、用位异或运算来实现，也是效率最</description>
    </item>
    
  </channel>
</rss>